<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Newstrong‘s blog</title>
    <description>关于Android开发AND探索发现世界的美好</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 28 Jul 2020 13:53:00 +0800</pubDate>
    <lastBuildDate>Tue, 28 Jul 2020 13:53:00 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Android Gradle插件发行说明</title>
        <description>&lt;h1 id=&quot;android-gradle插件发行说明&quot;&gt;Android Gradle插件发行说明&lt;/h1&gt;

&lt;p&gt;Android Studio构建系统基于Gradle，而Android Gradle插件添加了一些特定于构建Android应用的功能。尽管通常使用Android Studio同步更新Android插件，但该插件（以及Gradle系统的其余部分）可以独立于Android Studio运行，并且可以单独进行更新。&lt;/p&gt;

&lt;p&gt;本页说明如何使您的Gradle工具保持最新状态以及最新更新。&lt;/p&gt;

&lt;p&gt;有关如何使用Gradle配置Android构建的详细信息，请参见以下页面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/build&quot;&gt;配置构建&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/&quot;&gt;Android插件DSL参考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/current/dsl/&quot;&gt;Gradle DSL参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关Gradle构建系统的更多信息，请参阅&lt;a href=&quot;https://docs.gradle.org/current/userguide/userguide.html&quot;&gt;Gradle用户指南&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;更新android-gradle插件&quot;&gt;更新Android Gradle插件&lt;/h2&gt;

&lt;p&gt;更新Android Studio时，您可能会提示您自动将Android Gradle插件更新为最新的可用版本。您可以选择接受更新，也可以根据项目的构建要求手动指定版本。&lt;/p&gt;

&lt;p&gt;您可以在Android Studio 的“ &lt;strong&gt;文件”&lt;/strong&gt; &amp;gt;“ &lt;strong&gt;项目结构”&lt;/strong&gt; &amp;gt;“ &lt;strong&gt;项目”&lt;/strong&gt;菜单中或顶级&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中指定插件版本。插件版本适用于该Android Studio项目中内置的所有模块。以下示例将插件从&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件设置为版本4.0.0 ：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;err&quot;&gt;存储库&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Gradle 4.1及更高版本使用// google（）方法来支持Google的Maven 存储库。并且您需要包含此仓库才能下载// Android Gradle插件3.0.0或更高版本。        google （）... }     依赖项{         classpath'com.android.tools.build :gradle:4.0.0' } }&lt;/span&gt;
        
        
        

        
    


    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt;您不应在版本号中使用动态依赖项，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;'com.android.tools.build:gradle:2.+'&lt;/code&gt;。使用此功能可能会导致版本意外更新，并难以解决版本差异。&lt;/p&gt;

&lt;p&gt;如果尚未下载指定的插件版本，则Gradle会在您下次构建项目时下载它，或 从Android Studio菜单栏中单击&lt;strong&gt;工具&lt;/strong&gt; &amp;gt; &lt;strong&gt;Android&lt;/strong&gt; &amp;gt; &lt;strong&gt;与Gradle文件同步项目&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;更新摇篮&quot;&gt;更新摇篮&lt;/h2&gt;

&lt;p&gt;更新Android Studio时，可能会提示您也将Gradle更新到最新的可用版本。您可以选择接受更新，也可以根据项目的构建要求手动指定版本。&lt;/p&gt;

&lt;p&gt;下表列出了每个版本的Android Gradle插件所需的Gradle版本。为了获得最佳性能，您应该使用Gradle和插件的最新版本。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;插件版本&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;所需的Gradle版本&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.0.0-1.1.3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.2.1-2.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.2.0-1.3.1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.2.1-2.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.2.1-2.13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.0.0-2.1.2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.10-2.13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.1.3-2.2.3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.14.1+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2.3.0+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.3+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.0.0+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4.1+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.1.0+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4.4+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.2.0-3.2.1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4.6+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.3.0-3.3.3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4.10.1+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.4.0-3.4.3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5.1.1+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.5.0-3.5.4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5.4.1+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.6.0-3.6.4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5.6.4+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4.0.0+&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6.1.1+&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;您可以在Android Studio 的“ &lt;strong&gt;文件”&lt;/strong&gt; &amp;gt;“ &lt;strong&gt;项目结构”&lt;/strong&gt; &amp;gt;“ &lt;strong&gt;项目”&lt;/strong&gt;菜单中指定Gradle版本，也可以在&lt;strong&gt;文件中&lt;/strong&gt;编辑Gradle发行参考 &lt;code class=&quot;highlighter-rouge&quot;&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt;。以下示例在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle-wrapper.properties&lt;/code&gt;文件中将Gradle版本设置为6.1.1 。&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;distributionUrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;https&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\：&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//services.gradle.org/distributions/gradle-6.1.1-all.zip ...&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4002020年4月&quot;&gt;4.0.0（2020年4月）&lt;/h2&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/6.1.1/release-notes.html&quot;&gt;摇篮6.1.1&lt;/a&gt;。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;SDK Build Tools 29.0.2&lt;/a&gt;或更高版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4.0.1（2020年7月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持与新的默认设置和&lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility&quot;&gt;Android 11中软件包可见性的&lt;/a&gt;功能兼容。&lt;/p&gt;

&lt;p&gt;在以前的Android版本中，可以查看设备上安装的所有应用程序的列表。从Android 11（API级别30）开始，默认情况下，应用程序只能访问已过滤的已安装软件包列表。要查看系统上更广泛的应用程序列表，您现在需要 在应用程序或库的Android清单中&lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility#package-name&quot;&gt;添加一个``元素&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Android Gradle插件4.1+已经与新&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;queries&amp;gt;&lt;/code&gt;声明兼容 ；但是，旧版本不兼容。如果添加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;queries&amp;gt;&lt;/code&gt;元素，或者开始依赖支持目标Android 11的库或SDK，则在构建应用程序时可能会遇到清单合并错误。&lt;/p&gt;

&lt;p&gt;为解决此问题，我们发布了AGP 3.3及更高版本的一组补丁。如果您使用的是AGP的旧版本，请 &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#updating-plugin&quot;&gt;升级&lt;/a&gt; 到以下版本之一：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;strong&gt;如果您使用的是 AGP版本…&lt;/strong&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;strong&gt;…升级到：&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.0。*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4.0.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.6。*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.6.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.5。*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.5.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.4。*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.4.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.3。*&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.3.3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;有关此新功能的更多信息，请参阅 &lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility&quot;&gt;Android 11中的程序包可见性&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;新功能&quot;&gt;新功能&lt;/h3&gt;

&lt;p&gt;此版本的Android Gradle插件包含以下新功能。&lt;/p&gt;

&lt;h4 id=&quot;支持android-studio构建分析器&quot;&gt;支持Android Studio构建分析器&lt;/h4&gt;

&lt;p&gt;“ &lt;strong&gt;构建分析器”&lt;/strong&gt;窗口可帮助您了解和诊断构建过程中的问题，例如禁用的优化和配置不正确的任务。当您将Android Studio 4.0及更高版本与Android Gradle插件&lt;code class=&quot;highlighter-rouge&quot;&gt;4.0.0&lt;/code&gt;及更高版本配合使用时，此功能可用。您可以 从Android Studio 打开“ &lt;strong&gt;构建分析器”&lt;/strong&gt;窗口，如下所示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果尚未执行此操作，请通过从菜单栏中选择&lt;strong&gt;Build&amp;gt; Make Project&lt;/strong&gt;来构建您的应用程序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从菜单栏中选择&lt;strong&gt;查看&amp;gt;工具窗口&amp;gt;构建&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在“&lt;/p&gt;

    &lt;p&gt;生成”&lt;/p&gt;

    &lt;p&gt;窗口中，以下列方式之一打开“&lt;/p&gt;

    &lt;p&gt;生成分析器”&lt;/p&gt;

    &lt;p&gt;窗口：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Android Studio完成构建项目后，单击“ &lt;strong&gt;构建分析器”&lt;/strong&gt;选项卡。&lt;/li&gt;
      &lt;li&gt;Android Studio完成构建项目后，单击“ &lt;strong&gt;构建输出”&lt;/strong&gt;窗口右侧的链接。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://developer.android.com/build/build-analyzer/plugins-breakdown.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“ &lt;strong&gt;构建分析器”&lt;/strong&gt;窗口在左侧的树中组织了可能的构建问题。您可以检查并单击每个问题，以在右侧面板中调查其详细信息。当Android Studio分析您的构建时，它将计算确定构建持续时间的一组任务，并提供可视化帮助您了解每个任务的影响。您还可以通过展开“ &lt;strong&gt;警告”&lt;/strong&gt;节点来获取有关警告的详细信息。&lt;/p&gt;

&lt;p&gt;要了解更多信息，请阅读&lt;a href=&quot;https://developer.android.com/studio/build/build-analyzer&quot;&gt;识别构建速度回归&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;java-8库在d8和r8中逐渐消失&quot;&gt;Java 8库在D8和R8中逐渐消失&lt;/h4&gt;

&lt;p&gt;Android Gradle插件现在支持使用多种Java 8语言API，而无需为您的应用设置最低API级别。&lt;/p&gt;

&lt;p&gt;通过一个称为&lt;em&gt;desugaring&lt;/em&gt;的过程，Android Studio 3.0及更高版本中的DEX编译器D8已经为Java 8语言功能（例如lambda表达式，默认接口方法，尝试资源等）提供了实质性支持。在Android Studio 4.0中，已将废糖处理引擎扩展为能够对Java语言API进行糖化。这意味着您现在可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.streams&lt;/code&gt;支持较早版本的Android的应用程序中包含仅在最新的Android版本（例如）中可用的标准语言API 。&lt;/p&gt;

&lt;p&gt;此版本支持以下一组API：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;顺序流（&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.stream&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;的子集 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.time&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.function&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;最近添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.{Map,Collection,Comparator}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;选配（&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Optional&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.OptionalInt&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.OptionalDouble&lt;/code&gt;）和其他一些新的类与上述API有用&lt;/li&gt;
  &lt;li&gt;一些补充&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.concurrent.atomic&lt;/code&gt;（在新的方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicLong&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicReference&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt; （已修复Android 5.0的错误）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了支持这些语言API，D8会编译一个单独的库DEX文件，其中包含缺少的API的实现，并将其包含在您的应用程序中。取消调试过程将重写您的应用程序代码，以在运行时使用此库。&lt;/p&gt;

&lt;p&gt;要启用对这些语言API的支持，请在模块&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中包括以下内容：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;defaultConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Required when setting minSdkVersion to 20 or lower&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;multiDexEnabled&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;compileOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Flag to enable support for the new language APIs&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;coreLibraryDesugaringEnabled&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Sets Java compatibility to Java 8&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sourceCompatibility&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JavaVersion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;VERSION_1_8&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;targetCompatibility&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JavaVersion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;VERSION_1_8&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;coreLibraryDesugaring&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'com.android.tools:desugar_jdk_libs:1.0.4'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;启用或禁用构建功能的新选项&quot;&gt;启用或禁用构建功能的新选项&lt;/h4&gt;

&lt;p&gt;Android Gradle插件4.0.0引入了一种新方法来控制您要启用和禁用的构建功能，例如视图绑定和数据绑定。添加新功能后，默认情况下将禁用它们。然后，您可以使用该&lt;code class=&quot;highlighter-rouge&quot;&gt;buildFeatures&lt;/code&gt;块仅启用所需的功能，它可以帮助您优化项目的构建性能。您可以在模块级&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中为每个模块设置选项，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// The default value for each feature is shown below. You can change the value to&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// override the default behavior.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buildFeatures&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to generate a BuildConfig class.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;buildConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to support View Binding.&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Note that the viewBinding.enabled property is now deprecated.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;viewBinding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to support Data Binding.&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Note that the dataBinding.enabled property is now deprecated.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dataBinding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to generate binder classes for your AIDL files.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;aidl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to support RenderScript.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;renderScript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to support injecting custom variables into the module’s R class.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;resValues&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Determines whether to support shader AOT compilation.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;shaders&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;您还可以通过在项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包含以下一项或多项内容，为项目中所有模块指定这些功能的默认设置 ，如下所示。请记住，您仍然可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;buildFeatures&lt;/code&gt;模块级&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中的 块来覆盖这些项目范围的默认设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.defaults.buildfeatures.buildconfig=true
android.defaults.buildfeatures.aidl=true
android.defaults.buildfeatures.renderscript=true
android.defaults.buildfeatures.resvalues=true
android.defaults.buildfeatures.shaders=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;功能上的依存关系&quot;&gt;功能上的依存关系&lt;/h4&gt;

&lt;p&gt;在早期版本的Android Gradle插件中，所有动态功能模块都只能依赖于应用程序的基本模块。现在，当使用Android Gradle插件4.0.0时，您可以包括一个依赖于另一个功能模块的功能模块。也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;:video&lt;/code&gt;功能可以取决于&lt;code class=&quot;highlighter-rouge&quot;&gt;:camera&lt;/code&gt;功能，而功能取决于基础模块，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://developer.android.com/images/app-bundle/feature-on-feature.png&quot; alt=&quot;功能依赖功能&quot; /&gt;&lt;/p&gt;

&lt;p&gt;动态功能&lt;code class=&quot;highlighter-rouge&quot;&gt;:video&lt;/code&gt;取决于feature &lt;code class=&quot;highlighter-rouge&quot;&gt;:camera&lt;/code&gt;，后者取决于基本&lt;code class=&quot;highlighter-rouge&quot;&gt;:app&lt;/code&gt;模块。&lt;/p&gt;

&lt;p&gt;这意味着当您的应用程序请求下载动态功能模块时，该应用程序还会下载其依赖的其他功能模块。您之后&lt;a href=&quot;https://developer.android.com/studio/projects/dynamic-delivery/on-demand-delivery&quot;&gt;创建动态功能模块，&lt;/a&gt; 为您的应用程序，你可以声明在模块的一个功能上特征依赖 &lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;:video&lt;/code&gt;模块声明对&lt;code class=&quot;highlighter-rouge&quot;&gt;:camera&lt;/code&gt;以下项的依赖关系 ：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// In the build.gradle file of the ':video' module.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// All dynamic feature modules must declare a dependency&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on the base module.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;':app'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Declares that this module also depends on the 'camera'&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// dynamic feature module.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;':camera'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外，您应该通过在菜单栏中单击“ &lt;strong&gt;帮助”&amp;gt;“编辑自定义VM选项&lt;/strong&gt; ”并启用以下功能，启用Android Studio中的“功能对功能的依赖关系”功能（例如，在编辑“运行”配置时支持该功能）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;-Drundebug.feature.on.feature=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;依赖元数据&quot;&gt;依赖元数据&lt;/h4&gt;

&lt;p&gt;使用Android Gradle插件4.0.0及更高版本构建应用时，该插件包含描述已编译到应用中的依赖项的元数据。上载应用程序时，Play控制台会检查此元数据，为您提供以下好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取有关您的应用使用的SDK和依赖项的已知问题的警报&lt;/li&gt;
  &lt;li&gt;收到可行的反馈来解决这些问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据经过压缩，通过Google Play签名密钥加密，并存储在发布应用的签名栏中。但是，您可以自己在以下目录中的本地中间构建文件中检查元数据： &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;project&amp;gt;/&amp;lt;module&amp;gt;/build/outputs/sdk-dependencies/release/sdkDependency.txt&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果您不想共享此信息，可以通过在模块&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中添加以下内容来退出：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dependenciesInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Disables dependency metadata when building APKs.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;includeInApk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Disables dependency metadata when building Android App Bundles.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;includeInBundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;从aar依赖项导入本机库&quot;&gt;从AAR依赖项导入本机库&lt;/h4&gt;

&lt;p&gt;现在，您可以从应用程序的AAR依赖项导入C / C ++库。当您遵循以下描述的配置步骤时，Gradle会自动使这些本机库可用于您的外部本机构建系统（例如CMake）。请注意，Gradle仅使这些库可用于您的构建。您仍然必须配置构建脚本以使用它们。&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&quot;https://google.github.io/prefab/&quot;&gt;Prefab&lt;/a&gt;软件包格式导出库。&lt;/p&gt;

&lt;p&gt;每个依赖项最多可以公开一个包含一个或多个模块的Prefab软件包。预制模块是单个库，可以是共享库，静态库或仅标头库。&lt;/p&gt;

&lt;p&gt;通常，程序包名称与Maven工件名称匹配，模块名称与库名称匹配，但这并不总是正确的。因为您需要知道库的包和模块名称，所以可能需要查阅依赖项的文档来确定这些名称是什么。&lt;/p&gt;

&lt;h5 id=&quot;配置您的外部本机构建系统&quot;&gt;配置您的外部本机构建系统&lt;/h5&gt;

&lt;p&gt;要查看您需要执行的步骤，请单击您计划使用的外部本机构建系统。&lt;/p&gt;

&lt;p&gt;CMake的 ndk构建&lt;/p&gt;

&lt;p&gt;AAR中包含的本机依赖项通过&lt;a href=&quot;https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html&quot;&gt;CMAKE_FIND_ROOT_PATH&lt;/a&gt;变量公开给您的CMake项目 。调用CMake时，Gradle会自动设置此值，因此，如果您的构建系统修改了此变量，请确保附加而不是分配给它。&lt;/p&gt;

&lt;p&gt;每个依赖项都会向您的CMake构建公开一个&lt;a href=&quot;https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#config-file-packages&quot;&gt;配置文件包&lt;/a&gt;，您可以使用&lt;a href=&quot;https://cmake.org/cmake/help/latest/command/find_package.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find_package&lt;/code&gt;&lt;/a&gt;命令将其导入。此命令搜索与给定软件包名称和版本匹配的配置文件软件包，并公开它定义要在构建中使用的目标。例如，如果您的应用程序定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;libapp.so&lt;/code&gt;并使用curl，则应在&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;文件中包含以下内容 ：&lt;/p&gt;

&lt;div class=&quot;language-cmake highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;add_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;app SHARED app.cpp&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Add these two lines.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;find_package&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;curl REQUIRED CONFIG&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;target_link_libraries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;app curl::curl&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;您现在可以&lt;code class=&quot;highlighter-rouge&quot;&gt;#include &quot;curl/curl.h&quot;&lt;/code&gt;在中指定&lt;code class=&quot;highlighter-rouge&quot;&gt;app.cpp&lt;/code&gt;。当你建立你的项目，你的外部原始构建系统自动链接&lt;code class=&quot;highlighter-rouge&quot;&gt;libapp.so&lt;/code&gt; 反对&lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl.so&lt;/code&gt;和包&lt;code class=&quot;highlighter-rouge&quot;&gt;libcurl.so&lt;/code&gt;的APK或应用捆绑。有关其他信息，请参见&lt;a href=&quot;https://github.com/android/ndk-samples/tree/master/prefab/curl-ssl&quot;&gt;curl预制样本&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;行为改变&quot;&gt;行为改变&lt;/h3&gt;

&lt;p&gt;使用此版本的插件时，您可能会遇到以下行为更改。&lt;/p&gt;

&lt;h4 id=&quot;删除了功能和-instantapp-android-gradle插件&quot;&gt;删除了“功能”和“ instantapp” Android Gradle插件&lt;/h4&gt;

&lt;p&gt;Android Gradle插件3.6.0不推荐使用Feature插件（&lt;code class=&quot;highlighter-rouge&quot;&gt;com.android.feature&lt;/code&gt;）和Instant App插件（&lt;code class=&quot;highlighter-rouge&quot;&gt;com.android.instantapp&lt;/code&gt;），而建议使用Dynamic Feature插件（&lt;code class=&quot;highlighter-rouge&quot;&gt;com.android.dynamic-feature&lt;/code&gt;）使用&lt;a href=&quot;https://developer.android.com/guide/app-bundle&quot;&gt;Android App Bundles&lt;/a&gt;构建和打包您的即时应用&lt;a href=&quot;https://developer.android.com/guide/app-bundle&quot;&gt;程序&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在Android Gradle插件4.0.0及更高版本中，这些不推荐使用的插件已被完全删除。因此，要使用最新的Android Gradle插件，您需要&lt;a href=&quot;https://developer.android.com/topic/google-play-instant/feature-module-migration&quot;&gt;迁移即时应用程序以支持Android App Bundles&lt;/a&gt;。通过迁移即时应用程序，您可以利用应用程序包的好处并&lt;a href=&quot;https://android-developers.googleblog.com/2019/04/google-play-instant-feature-plugin.html&quot;&gt;简化应用程序的模块化设计&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;要在Android Studio 4.0及更高版本中打开使用已删除插件的项目，该项目必须使用Android Gradle插件3.6.0或更低版本。&lt;/p&gt;

&lt;h4 id=&quot;单独的注释处理功能已删除&quot;&gt;单独的注释处理功能已删除&lt;/h4&gt;

&lt;p&gt;将注释处理分离为专用任务的功能已被删除。当仅Java项目中使用非增量注释处理器时，此选项用于维护增量Java编译。通过在文件中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;android.enableSeparateAnnotationProcessing&lt;/code&gt;来启用 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;该功能 &lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;，该功能将不再起作用。&lt;/p&gt;

&lt;p&gt;相反，您应该迁移到&lt;a href=&quot;https://developer.android.com/studio/build/optimize-your-build#annotation_processors&quot;&gt;使用增量注释处理器&lt;/a&gt;来提高构建性能。&lt;/p&gt;

&lt;h4 id=&quot;includecompileclasspath已弃用&quot;&gt;includeCompileClasspath已弃用&lt;/h4&gt;

&lt;p&gt;Android Gradle插件不再检查或包括您在编译类路径上声明的注释处理器，并且 &lt;code class=&quot;highlighter-rouge&quot;&gt;annotationProcessorOptions.includeCompileClasspath&lt;/code&gt;DSL属性不再起作用。如果在编译类路径上包含注释处理器，则可能会出现以下错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Error: Annotation processors must be explicitly declared now.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;若要解决此问题，您必须&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;annotationProcessor&lt;/code&gt;依赖项配置在文件中包括注释处理器 。要了解更多信息，请阅读&lt;a href=&quot;https://developer.android.com/studio/build/dependencies#annotation_processor&quot;&gt;添加注释处理器&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;自动打包cmake使用的预构建依赖项&quot;&gt;自动打包CMake使用的预构建依赖项&lt;/h3&gt;

&lt;p&gt;早期版本的Android Gradle插件要求您使用显式打包CMake外部本机内部版本使用的所有预构建库 &lt;code class=&quot;highlighter-rouge&quot;&gt;jniLibs&lt;/code&gt;。您可能在&lt;code class=&quot;highlighter-rouge&quot;&gt;src/main/jniLibs&lt;/code&gt;模块目录中或您的&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt; 文件中配置的其他目录中具有库：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;sourceSets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// The libs directory contains prebuilt libraries that are used by the&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// app's library defined in CMakeLists.txt via an IMPORTED target.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jniLibs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;srcDirs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'libs'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用Android Gradle Plugin 4.0时，不再需要上述配置，并且会导致构建失败：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;* What went wrong:
Execution failed for task ':app:mergeDebugNativeLibs'.
&amp;gt; A failure occurred while executing com.android.build.gradle.internal.tasks.Workers$ActionFacade
   &amp;gt; More than one file was found with OS independent path 'lib/x86/libprebuilt.so'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，外部本机构建会自动打包这些库，因此将&lt;code class=&quot;highlighter-rouge&quot;&gt;jniLibs&lt;/code&gt;结果与库明确打包在一起。为避免构建错误，请将预构建的库移到外部位置&lt;code class=&quot;highlighter-rouge&quot;&gt;jniLibs&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;jniLibs&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt; 文件中删除配置。&lt;/p&gt;

&lt;h3 id=&quot;已知的问题&quot;&gt;已知的问题&lt;/h3&gt;

&lt;p&gt;本部分描述了Android Gradle插件4.0.0中存在的已知问题。&lt;/p&gt;

&lt;h4 id=&quot;gradle工作者机制中的比赛条件&quot;&gt;Gradle工作者机制中的比赛条件&lt;/h4&gt;

&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--no-daemon&lt;/code&gt;Gradle 6.3和更低版本以及更低版本运行时，Android Gradle插件4.0中的更改可能会在Gradle中触发竞争条件，从而导致构建在构建完成后挂起。&lt;/p&gt;

&lt;p&gt;此问题将在Gradle 6.4中修复。&lt;/p&gt;

&lt;h2 id=&quot;3602020年2月&quot;&gt;3.6.0（2020年2月）&lt;/h2&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/5.6.4/release-notes.html&quot;&gt;摇篮5.6.4&lt;/a&gt;。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;SDK Build Tools 28.0.3&lt;/a&gt;或更高版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.6.4（2020年7月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持与新的默认设置和&lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility&quot;&gt;Android 11中软件包可见性的&lt;/a&gt;功能兼容 。&lt;/p&gt;

&lt;p&gt;有关详细信息，请参见&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#4.0.1&quot;&gt;4.0.1发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;新功能-1&quot;&gt;新功能&lt;/h3&gt;

&lt;p&gt;此版本的Android Gradle插件包含以下新功能。&lt;/p&gt;

&lt;h4 id=&quot;视图绑定&quot;&gt;视图绑定&lt;/h4&gt;

&lt;p&gt;在代码中引用视图时，视图绑定可提供编译时安全性。现在&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;，您可以替换为自动生成的绑定类参考。要开始使用View绑定，请在每个模块的&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中包括以下内容 ：&lt;/p&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;viewBinding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要了解更多信息，请阅读&lt;a href=&quot;https://developer.android.com/topic/libraries/view-binding&quot;&gt;View Binding文档&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;支持maven-publish插件&quot;&gt;支持Maven Publish插件&lt;/h4&gt;

&lt;p&gt;Android Gradle插件包括对&lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;Maven Publish Gradle插件的&lt;/a&gt;支持，该 &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;插件&lt;/a&gt;使您可以将构建工件发布到Apache Maven存储库。Android的摇篮插件创建一个 &lt;a href=&quot;https://docs.gradle.org/current/userguide/dependency_management_terminology.html#sub:terminology_component&quot;&gt;&lt;em&gt;组件&lt;/em&gt;&lt;/a&gt; 在您的应用程序或者库模块，您可以使用自定义每个构建变量神器 &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:publications&quot;&gt;&lt;em&gt;发布&lt;/em&gt;&lt;/a&gt; 到Maven仓库。&lt;/p&gt;

&lt;p&gt;要了解更多信息，请转至有关如何&lt;a href=&quot;https://developer.android.com/studio/build/maven-publish-plugin&quot;&gt;使用Maven Publish插件的页面&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;新的默认打包工具&quot;&gt;新的默认打包工具&lt;/h4&gt;

&lt;p&gt;在构建应用程序的调试版本时，该插件使用名为&lt;em&gt;zipflinger&lt;/em&gt;的新打包工具来构建APK。此新工具应可提高构建速度。如果新的打包工具无法正常运行，请&lt;a href=&quot;https://developer.android.com/studio/report-bugs&quot;&gt;报告错误&lt;/a&gt;。您可以通过在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包含以下内容来恢复使用旧的打包工具：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.useNewApkCreator=false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;本机版本归因&quot;&gt;本机版本归因&lt;/h4&gt;

&lt;p&gt;现在，您可以确定Clang构建和链接项目中每个C / C ++文件所花费的时间。Gradle可以输出包含这些编译器事件时间戳的Chrome跟踪，因此您可以更好地了解构建项目所需的时间。要输出此构建归因文件，请执行以下操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Pandroid.enableProfileJson=true&lt;/code&gt;运行Gradle构建时添加标志。例如：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gradlew assembleDebug -Pandroid.enableProfileJson=true&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开Chrome浏览器，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;chrome://tracing&lt;/code&gt;在搜索栏中输入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单击&lt;strong&gt;加载&lt;/strong&gt;按钮，然后导航&lt;code class=&quot;highlighter-rouge&quot;&gt;project-root/build/android-profile&lt;/code&gt; 以找到文件。该文件名为。&lt;code class=&quot;highlighter-rouge&quot;&gt;profile-timestamp.json.gz&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;您可以在查看器顶部附近看到本机构建归因数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://developer.android.com/studio/images/releases/native-build-attribution.png&quot; alt=&quot;Chrome中的本机版本归因跟踪&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;行为改变-1&quot;&gt;行为改变&lt;/h3&gt;

&lt;p&gt;使用此版本的插件时，您可能会遇到以下行为更改。&lt;/p&gt;

&lt;h4 id=&quot;本地库默认打包为未压缩&quot;&gt;本地库默认打包为未压缩&lt;/h4&gt;

&lt;p&gt;现在，当您构建应用程序时，该插件默认设置&lt;code class=&quot;highlighter-rouge&quot;&gt;extractNativeLibs&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;false&quot;&lt;/code&gt;。也就是说，您的本机库是页面对齐的，并且未经压缩打包。虽然这会导致较大的上载大小，但您的用户将从以下方面受益：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用程序安装尺寸较小，因为平台可以直接从已安装的APK访问本机库，而无需创建库的副本。&lt;/li&gt;
  &lt;li&gt;下载大小较小，因为当您在APK或Android App Bundle中包含未压缩的本机库时，Play Store压缩通常会更好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果您想让Android Gradle插件打包压缩的本机库，请在应用清单中添加以下内容：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;application&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:extractNativeLibs=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/application&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;默认的ndk版本&quot;&gt;默认的NDK版本&lt;/h4&gt;

&lt;p&gt;如果您下载了多个版本的NDK，则Android Gradle插件现在会选择一个默认版本来编译您的源代码文件。以前，该插件选择了NDK的最新下载版本。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;android.ndkVersion&lt;/code&gt;模块&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中的 属性来覆盖插件选择的默认值。&lt;/p&gt;

&lt;h4 id=&quot;简化的r类生成&quot;&gt;简化的R类生成&lt;/h4&gt;

&lt;p&gt;Android Gradle插件通过为项目中的每个库模块仅生成一个R类并与其他模块依赖项共享这些R类来简化编译类路径。此优化应该可以加快构建速度，但是需要牢记以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为编译器与上游模块依赖项共享R类，所以项目中的每个模块都使用唯一的包名称非常重要。&lt;/li&gt;
  &lt;li&gt;库的R类对其他项目依赖项的可见性由用于将库包括为依赖项的配置确定。例如，如果库A将库B包含为“ api”依赖项，则库A和其他依赖库A的库都可以访问库B的R类。但是，如果库A使用&lt;code class=&quot;highlighter-rouge&quot;&gt;implementation&lt;/code&gt;依赖项配置，则其他库可能无法访问库B的R类。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/build/dependencies#dependency_configurations&quot;&gt;依赖项配置&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;删除默认配置中缺少的资源&quot;&gt;删除默认配置中缺少的资源&lt;/h4&gt;

&lt;p&gt;对于库模块，如果包含的语言资源未包含在默认资源集中（例如，如果包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello_world&lt;/code&gt;为字符串资源，&lt;code class=&quot;highlighter-rouge&quot;&gt;/values-es/strings.xml&lt;/code&gt;但未在其中定义该资源）&lt;code class=&quot;highlighter-rouge&quot;&gt;/values/strings.xml&lt;/code&gt;，则Android Gradle插件在编译项目时，不再包含该资源。此行为更改应导致更少的&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Not Found&lt;/code&gt;运行时异常并提高构建速度。&lt;/p&gt;

&lt;h4 id=&quot;d8现在遵守class注释保留策略&quot;&gt;D8现在遵守CLASS注释保留策略&lt;/h4&gt;

&lt;p&gt;现在，在编译应用程序时，D8会考虑注释何时应用CLASS保留策略，并且这些注释在运行时不再可用。当将应用程序的目标SDK设置为API级别23时，也会出现此行为，该行为以前允许在运行时使用较旧版本的Android Gradle插件和D8编译应用程序时访问这些批注。&lt;/p&gt;

&lt;h4 id=&quot;其他行为改变&quot;&gt;其他行为改变&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;aaptOptions.noCompress&lt;/code&gt; 不再在所有平台上都区分大小写（对于APK和bundle），并尊重使用大写字符的路径。&lt;/li&gt;
  &lt;li&gt;现在，默认情况下，数据绑定是增量的。要了解更多信息，请参阅 &lt;a href=&quot;https://issuetracker.google.com/110061530&quot;&gt;问题＃110061530&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;现在，所有单元测试（包括Roboelectric单元测试）都可以完全缓存。要了解更多信息，请参阅 &lt;a href=&quot;https://issuetracker.google.com/115873047&quot;&gt;问题＃115873047&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bug修复&quot;&gt;Bug修复&lt;/h3&gt;

&lt;p&gt;此版本的Android Gradle插件包含以下错误修复：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在，使用数据绑定的库模块支持Robolectric单元测试。要了解更多信息，请参阅 &lt;a href=&quot;https://issuetracker.google.com/126775542&quot;&gt;问题＃126775542&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;现在，&lt;code class=&quot;highlighter-rouge&quot;&gt;connectedAndroidTest&lt;/code&gt;在启用Gradle的&lt;a href=&quot;https://guides.gradle.org/performance/#parallel_execution&quot;&gt;并行执行模式&lt;/a&gt;的&lt;a href=&quot;https://guides.gradle.org/performance/#parallel_execution&quot;&gt;情况下，&lt;/a&gt;您可以跨多个模块运行任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;已知的问题-1&quot;&gt;已知的问题&lt;/h3&gt;

&lt;p&gt;本节介绍了Android Gradle插件3.6.0中存在的已知问题。&lt;/p&gt;

&lt;h4 id=&quot;android-lint任务的性能降低&quot;&gt;Android Lint任务的性能降低&lt;/h4&gt;

&lt;p&gt;由于分析基础结构的回归，Android Lint可能需要更长的时间才能完成某些项目，从而导致在某些代码构造中对lambda的推断类型的计算速度较慢。&lt;/p&gt;

&lt;p&gt;该问题被报告为&lt;a href=&quot;https://youtrack.jetbrains.com/issue/IDEA-229655&quot;&gt;IDEA中的错误，&lt;/a&gt; 并将在Android Gradle Plugin 4.0中修复。&lt;/p&gt;

&lt;h4 id=&quot;缺少舱单&quot;&gt;缺少舱单&lt;/h4&gt;

&lt;p&gt;如果您的应用在清单中定义了自定义权限，则Android Gradle插件通常会生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Manifest.java&lt;/code&gt;包含您的自定义权限作为字符串常量的类。该插件将此类与您的应用程序打包在一起，因此您可以在运行时更轻松地引用这些权限。&lt;/p&gt;

&lt;p&gt;Android Gradle插件3.6.0中中断了生成清单类的过程。如果使用此版本的插件构建应用程序，并且该应用程序引用了清单类，则可能会看到&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassNotFoundException&lt;/code&gt;异常。要解决此问题，请执行以下任一操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;通过其完全限定的名称引用您的自定义权限。例如， &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot;&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;定义自己的常量，如下所示：&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomPermissions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;permission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DEADLY_ACTIVITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3502019年8月&quot;&gt;3.5.0（2019年8月）&lt;/h2&gt;

&lt;p&gt;Android Gradle插件3.5.0和&lt;a href=&quot;https://developer.android.com/studio/releases#3-5-0&quot;&gt;Android Studio 3.5&lt;/a&gt;是一个主要版本，是Project Marble的结果，Project Marble致力于改善Android开发人员工具的三个主要方面：系统运行状况，功能改进和修复错误。值得注意的是，&lt;a href=&quot;https://medium.com/androiddevelopers/improving-build-speed-in-android-studio-3e1425274837&quot;&gt;提高项目构建速度&lt;/a&gt; 是此更新的主要重点。&lt;/p&gt;

&lt;p&gt;有关这些更新和其他Project Marble更新的信息，请阅读&lt;a href=&quot;https://android-developers.googleblog.com/2019/05/android-studio-35-beta.html&quot;&gt;Android Developers博客文章&lt;/a&gt; 或以下部分。&lt;/p&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/5.4.1/release-notes.html&quot;&gt;摇篮5.4.1&lt;/a&gt;。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;SDK Build Tools 28.0.3&lt;/a&gt;或更高版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.5.4（2020年7月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持与新的默认设置和&lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility&quot;&gt;Android 11中软件包可见性的&lt;/a&gt;功能兼容 。&lt;/p&gt;

&lt;p&gt;有关详细信息，请参见&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#4.0.1&quot;&gt;4.0.1发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.3（2019年12月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次要更新支持Android Studio 3.5.3，并包括各种错误修复和性能改进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.2（2019年11月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次要更新支持Android Studio 3.5.2，并包括各种错误修复和性能改进。要查看重要的错误修复列表，请阅读&lt;a href=&quot;https://androidstudio.googleblog.com/2019/11/android-studio-352-available.html&quot;&gt; Release Updates博客&lt;/a&gt;上的相关文章 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.1（2019年10月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持Android Studio 3.5.1，并包括各种错误修复和性能改进。要查看重要的错误修复列表，请阅读&lt;a href=&quot;https://androidstudio.googleblog.com/2019/10/android-studio-351-available.html&quot;&gt; Release Updates博客&lt;/a&gt;上的相关文章 。&lt;/p&gt;

&lt;h3 id=&quot;增量注释处理&quot;&gt;增量注释处理&lt;/h3&gt;

&lt;p&gt;该&lt;a href=&quot;https://developer.android.com/reference/android/databinding/package-summary&quot;&gt;数据绑定&lt;/a&gt;注释处理器支持&lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_annotation_processing&quot;&gt;增量标注处理&lt;/a&gt; ，如果你设置&lt;code class=&quot;highlighter-rouge&quot;&gt;android.databinding.incremental=true&lt;/code&gt; 你的&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件。这种优化可以提高增量构建性能。有关优化注释处理器的完整列表，请参阅&lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#state_of_support_in_popular_annotation_processors&quot;&gt;增量注释处理器&lt;/a&gt;表。&lt;/p&gt;

&lt;p&gt;此外，KAPT 1.3.30和更高版本还支持增量注释处理器，您可以通过将其包含&lt;code class=&quot;highlighter-rouge&quot;&gt;kapt.incremental.apt=true&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中来启用它们。&lt;/p&gt;

&lt;h3 id=&quot;可缓存的单元测试&quot;&gt;可缓存的单元测试&lt;/h3&gt;

&lt;p&gt;通过将设置&lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.TestOptions.UnitTestOptions.html#com.android.build.gradle.internal.dsl.TestOptions.UnitTestOptions:includeAndroidResources&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;includeAndroidResources&lt;/code&gt;&lt;/a&gt; 为来启用单元测试以使用Android资源，资产和清单时&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，Android Gradle插件会生成包含绝对路径的测试配置文件，这会破坏缓存的可重定位性。您可以指示插件改为使用相对路径生成测试配置，这可以&lt;code class=&quot;highlighter-rouge&quot;&gt;AndroidUnitTest&lt;/code&gt;通过在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包含以下内容来使任务完全可缓存：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.testConfig.useRelativePath = true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;已知的问题-2&quot;&gt;已知的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用Kotlin Gradle插件1.3.31或更早版本时，在构建或同步项目时可能会看到以下警告：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;WARNING: API 'variant.getPackageLibrary()' is obsolete and has been replaced
         with 'variant.getPackageLibraryProvider()'.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;要解决&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-30784&quot;&gt;此问题&lt;/a&gt;，请将插件升级到1.3.40或更高版本。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3402019年4月&quot;&gt;3.4.0（2019年4月）&lt;/h2&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.gradle.org/5.1.1/release-notes.html&quot;&gt;Gradle 5.1.1&lt;/a&gt;或更高版本。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;使用Gradle 5.0和更高版本时，&lt;a href=&quot;https://docs.gradle.org/current/userguide/upgrading_version_4.html#rel5.0:default_memory_settings&quot;&gt;默认的Gradle守护程序内存堆大小&lt;/a&gt; 从1 GB减小到512 MB。这可能会导致构建性能下降。要覆盖此默认设置，请 在项目的文件中&lt;a href=&quot;https://docs.gradle.org/current/userguide/build_environment.html#sec:configuring_jvm_memory&quot;&gt;指定Gradle守护程序堆大小&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;SDK Build Tools 28.0.3&lt;/a&gt;或更高版本。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.4.3（2020年7月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持与新的默认设置和&lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility&quot;&gt;Android 11中软件包可见性的&lt;/a&gt;功能兼容 。&lt;/p&gt;

&lt;p&gt;有关详细信息，请参见&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#4.0.1&quot;&gt;4.0.1发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4.2（2019年7月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次要更新支持Android Studio 3.4.2，并包括各种错误修复和性能改进。要查看重要的错误修复列表，请阅读&lt;a href=&quot;https://androidstudio.googleblog.com/2019/07/android-studio-342-available.html&quot;&gt; Release Updates博客&lt;/a&gt;上的相关文章 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4.1（2019年5月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持Android Studio 3.4.1，并包括各种错误修复和性能改进。要查看重要的错误修复列表，请阅读&lt;a href=&quot;https://androidstudio.googleblog.com/2019/05/android-studio-341-available.html&quot;&gt; Release Updates博客&lt;/a&gt;上的相关文章 。&lt;/p&gt;

&lt;h3 id=&quot;新功能-2&quot;&gt;新功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;新的棉绒检查依赖项配置：&lt;/strong&gt;的行为&lt;code class=&quot;highlighter-rouge&quot;&gt;lintChecks&lt;/code&gt;已更改&lt;code class=&quot;highlighter-rouge&quot;&gt;lintPublish&lt;/code&gt;，并且引入了新的依赖项配置，使您可以更好地控制将哪些棉绒检查打包在Android库中。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lintChecks&lt;/code&gt;：这是一个现有配置，您应该将其用于只在本地构建项目时才运行的lint检查。如果您以前使用&lt;code class=&quot;highlighter-rouge&quot;&gt;lintChecks&lt;/code&gt;依赖项配置在已发布的AAR中包括了lint检查，则需要迁移这些依赖项以改为使用&lt;code class=&quot;highlighter-rouge&quot;&gt;lintPublish&lt;/code&gt;下面描述的新配置。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lintPublish&lt;/code&gt;：如下所示，在库项目中使用此新配置进行要包含在已发布的AAR中的棉绒检查。这意味着占用您的库的项目也会应用这些皮棉检查。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;以下代码示例在本地Android库项目中同时使用了两种依赖项配置。&lt;/p&gt;

    &lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Executes lint checks from the ':lint' project at build time.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lintChecks&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;':lint'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Packages lint checks from the ':lintpublish' in the published AAR.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lintPublish&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;':lintpublish'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通常，打包和签名任务应使整体构建速度有所提高。如果您发现与这些任务有关的性能下降，请&lt;a href=&quot;https://developer.android.com/studio/report-bugs&quot;&gt;报告错误&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;行为改变-2&quot;&gt;行为改变&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Android Instant Apps功能插件已弃用警告：&lt;/strong&gt;如果您仍在使用该&lt;code class=&quot;highlighter-rouge&quot;&gt;com.android.feature&lt;/code&gt;插件来构建即时应用，则Android Gradle插件3.4.0会向您抛出弃用警告。为了确保您仍可以在该插件的未来版本上构建即时应用程序，请将您的即时应用程序迁移到使用 &lt;a href=&quot;https://developer.android.com/studio/projects/dynamic-delivery&quot;&gt;动态功能插件&lt;/a&gt;，它还允许您从单个Android应用程序包发布已安装和即时应用程序的体验。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;默认情况下启用R8：&lt;/strong&gt; R8一步就集成了除糖，缩小，模糊，优化和脱色功能- &lt;a href=&quot;https://www.google.com/url?q=https://android-developers.googleblog.com/2018/11/r8-new-code-shrinker-from-google-is.html&amp;amp;sa=D&amp;amp;ust=1551922493258000&amp;amp;usg=AFQjCNH0N1wuMX645n7giw0wjikzjm3WCA&quot;&gt;显着提高了构建性能&lt;/a&gt;。R8是在Android Gradle插件3.3.0中引入的，现在默认情况下使用插件3.4.0及更高版本对应用程序和Android库项目都启用了R8。&lt;/p&gt;

    &lt;p&gt;下图简要介绍了R8引入之前的编译过程。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://developer.android.com/studio/images/build/r8/compile_with_d8_proguard.png&quot; alt=&quot;在R8之前，ProGuard是与Dexing和Deugaring不同的编译步骤。&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;现在，使用R8，消糖，收缩，模糊，优化和变形（D8）都可以一步完成，如下所示。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://developer.android.com/studio/images/build/r8/compile_with_r8.png&quot; alt=&quot;使用R8，可以在单个编译步骤中执行除糖，缩小，模糊，优化和解密。&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;请记住，R8旨在与您现有的ProGuard规则配合使用，因此您可能无需采取任何措施即可从R8中受益。但是，由于ProGuard是专为Android项目设计的与ProGuard不同的技术，因此缩小和优化可能会删除ProGuard可能没有的代码。因此，在这种不太可能的情况下，您可能需要添加其他规则以将该代码保留在构建输出中。&lt;/p&gt;

    &lt;p&gt;如果您在使用R8时遇到问题，请阅读 &lt;a href=&quot;https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md&quot;&gt;R8兼容性常见问题解答，&lt;/a&gt; 以检查是否有解决问题的方法。如果未记录解决方案，请&lt;a href=&quot;https://issuetracker.google.com/issues/new?component=326788&amp;amp;template=1025938&quot;&gt;报告错误&lt;/a&gt;。您可以通过在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中添加以下行之一来禁用R8 ：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;# Disables R8 for Android Library modules only.
android.enableR8.libraries = false
# Disables R8 for all modules.
android.enableR8 = false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对于给定的构建类型，如果您在应用模块的文件中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;useProguard&lt;/code&gt;为，则无论您是否在项目文件中禁用R8，Android Gradle插件都会使用R8缩小该构建类型的应用代码。&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ndkCompile&lt;/code&gt;不建议使用：&lt;/strong&gt;现在，如果您尝试使用它&lt;code class=&quot;highlighter-rouge&quot;&gt;ndkBuild&lt;/code&gt;来编译本机库，则会出现构建错误 。您应该改用CMake或ndk-build将 &lt;a href=&quot;https://developer.android.com/studio/projects/add-native-code&quot;&gt;C和C ++代码添加到项目中&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;已知的问题-3&quot;&gt;已知的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当前未强制正确使用唯一的软件包名称，但在更高版本的插件上将变得更加严格。在Android Gradle插件版本3.4.0上，您可以通过在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt; 文件中添加以下行来选择检查项目是否声明了可接受的包名称。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.uniquePackageNames = true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;要了解有关通过Android Gradle插件设置软件包名称的更多信息，请参阅&lt;a href=&quot;https://developer.android.com/studio/build/application-id&quot;&gt;设置应用程序ID&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3302019年1月&quot;&gt;3.3.0（2019年1月）&lt;/h2&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.gradle.org/4.10.1/release-notes.html&quot;&gt;Gradle 4.10.1&lt;/a&gt;或更高版本。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;使用Gradle 5.0和更高版本时，&lt;a href=&quot;https://docs.gradle.org/current/userguide/upgrading_version_4.html#rel5.0:default_memory_settings&quot;&gt;默认的Gradle守护程序内存堆大小&lt;/a&gt; 从1 GB减小到512 MB。这可能会导致构建性能下降。要覆盖此默认设置，请 在项目的文件中&lt;a href=&quot;https://docs.gradle.org/current/userguide/build_environment.html#sec:configuring_jvm_memory&quot;&gt;指定Gradle守护程序堆大小&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;SDK Build Tools 28.0.3&lt;/a&gt;或更高版本。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.3.3（2020年7月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次更新支持与新的默认设置和&lt;a href=&quot;https://developer.android.com/preview/privacy/package-visibility&quot;&gt;Android 11中软件包可见性的&lt;/a&gt;功能兼容 。&lt;/p&gt;

&lt;p&gt;有关详细信息，请参见&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#4.0.1&quot;&gt;4.0.1发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.2（2019年3月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次要更新支持Android Studio 3.3.2，并包括各种错误修复和性能改进。要查看重要的错误修复列表，请阅读&lt;a href=&quot;https://androidstudio.googleblog.com/2019/03/android-studio-332-available.html&quot;&gt; Release Updates博客&lt;/a&gt;上的相关文章 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.1（2019年2月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此次要更新支持Android Studio 3.3.1，并包括各种错误修复和性能改进。&lt;/p&gt;

&lt;h3 id=&quot;新功能-3&quot;&gt;新功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;改进的类路径同步：&lt;/strong&gt;解决运行时的依赖关系并编译时的类路径时，Android Gradle插件会尝试修复某些跨多个类路径的依赖项的某些下游版本冲突。&lt;/p&gt;

    &lt;p&gt;例如，如果运行时类路径包括Library A版本2.0，而编译类路径包括Library A版本1.0，则插件会自动将对编译类路径的依赖关系更新为Library A版本2.0，以避免发生错误。&lt;/p&gt;

    &lt;p&gt;但是，如果运行时类路径包含库A版本1.0，而编译库包含库A版本2.0，则该插件不会将对编译类路径的依赖关系降级为库A版本1.0，因此会出现错误。要了解更多信息，请参见 &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#classpath_conflicts&quot;&gt;修复类路径之间的冲突&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用注释处理器时改进了增量Java编译：&lt;/strong&gt; 此更新通过改进对使用注释处理器时对增量Java编译的支持，减少了构建时间。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;此功能与Gradle 4.10.1及更高版本兼容，但由于&lt;a href=&quot;https://github.com/gradle/gradle/issues/8194&quot;&gt;Gradle问题8194&lt;/a&gt;导致Gradle 5.1除外。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;对于使用Kapt的项目（大多数仅限Kotlin的项目和Kotlin-Java混合项目）：&lt;/strong&gt;即使使用数据绑定或retro-lambda插件，也会启用增量Java编译。Kapt任务的注释处理尚未增量。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;对于不使用Kapt（纯Java的项目）的项目：&lt;/strong&gt;如果您使用所有支持注解处理器 &lt;a href=&quot;https://docs.gradle.org/4.10.1/userguide/java_plugin.html#sec:incremental_annotation_processing&quot;&gt;增量注释处理&lt;/a&gt;，增量Java编译默认情况下启用。要监视增量注释处理器的采用，请观看 &lt;a href=&quot;https://github.com/gradle/gradle/issues/5277&quot;&gt;Gradle问题5277&lt;/a&gt;。&lt;/p&gt;

        &lt;p&gt;但是，如果一个或多个注释处理器不支持增量构建，则不会启用增量Java编译。相反，您可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包含以下标志：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.enableSeparateAnnotationProcessing=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;当包含此标志时，Android Gradle插件将在单独的任务中执行注释处理器，并允许Java编译任务以增量方式运行。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用过时的API时可以提供更好的调试信息：&lt;/strong&gt;当插件检测到您正在使用不再受支持的API时，它现在可以提供更详细的信息来帮助您确定该API的使用位置。要查看其他信息，您需要在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包括以下内容：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.debug.obsoleteApi=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;您还可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;-Pandroid.debug.obsoleteApi=true&lt;/code&gt; 从命令行传递来启用该标志。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;您可以从命令行在动态功能模块上运行检测测试。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;行为改变-3&quot;&gt;行为改变&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;惰性任务配置：&lt;/strong&gt;插件现在使用 &lt;a href=&quot;https://docs.gradle.org/current/userguide/task_configuration_avoidance.html&quot;&gt;Gradle的新任务创建API&lt;/a&gt; 来避免初始化和配置完成当前构建不需要的任务（或不在执行任务图上的任务）。例如，如果您有多个构建变体，例如“ release”和“ debug”构建变体，而您正在构建应用程序的“ debug”版本，则该插件可以避免初始化和配置“ release”版本的任务。您的应用。&lt;/p&gt;

    &lt;p&gt;在Variants API中调用某些较旧的方法（例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;variant.getJavaCompile()&lt;/code&gt;）可能仍会强制执行任务配置。为确保您的构建针对延迟任务配置进行了优化，请调用新方法以返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;TaskProvider&lt;/code&gt; 对象，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;variant.getJavaCompileProvider()&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;如果您执行自定义构建任务，请学习如何 &lt;a href=&quot;https://docs.gradle.org/current/userguide/task_configuration_avoidance.html#sec:old_vs_new_configuration_api_overview&quot;&gt;适应Gradle的新任务创建API&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于给定的构建类型，在设置时&lt;code class=&quot;highlighter-rouge&quot;&gt;useProguard false&lt;/code&gt;，插件现在使用R8而不是ProGuard来缩小和模糊应用程序的代码和资源。要了解有关R8的更多信息，请阅读 Android开发者博客中的&lt;a href=&quot;https://android-developers.googleblog.com/2018/11/r8-new-code-shrinker-from-google-is.html&quot;&gt;这篇博客文章&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;为图书馆项目更快地生成R类：&lt;/strong&gt;以前，Android Gradle插件将为&lt;code class=&quot;highlighter-rouge&quot;&gt;R.java&lt;/code&gt;项目的每个依赖项生成一个文件，然后将这些R类与应用程序的其他类一起编译。现在，该插件会直接生成一个JAR，其中包含应用程序的已编译R类，而无需首先构建中间&lt;code class=&quot;highlighter-rouge&quot;&gt;R.java&lt;/code&gt;类。此优化可以显着提高包含许多库子项目和依赖项的项目的构建性能，并提高Android Studio中的索引编制速度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在构建&lt;a href=&quot;https://developer.android.com/guide/app-bundle&quot;&gt;Android应用程序捆绑包时&lt;/a&gt;，默认情况下，从该应用程序捆绑包生成的，面向Android 6.0（API级别23）或更高版本的APK现在包括本机库的未压缩版本。这种优化避免了设备制作库副本的需要，从而减小了应用程序的磁盘大小。如果您想禁用此优化，请在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中添加以下内容：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.bundle.enableUncompressedNativeLibs = false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;该插件会强制执行某些第三方插件的最低版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;单变量项目同步&lt;/strong&gt;：使 &lt;a href=&quot;https://developer.android.com/studio/build#sync-files&quot;&gt;项目&lt;/a&gt; 与构建配置&lt;a href=&quot;https://developer.android.com/studio/build#sync-files&quot;&gt;同步&lt;/a&gt;是让Android Studio了解项目结构的重要一步。但是，此过程对于大型项目可能很耗时。如果您的项目使用多个构建变体，则现在可以通过将项目同步限制为仅当前选择的变体来优化项目同步。&lt;/p&gt;

    &lt;p&gt;您需要将Android Studio 3.3或更高版本与Android Gradle Plugin 3.3.0或更高版本配合使用才能启用此优化。当满足这些要求时，IDE会在同步项目时提示您启用此优化。默认情况下，还会在新项目上启用优化。&lt;/p&gt;

    &lt;p&gt;要手动启用此优化，请点击&lt;strong&gt;文件&amp;gt;设置&amp;gt;实验&lt;/strong&gt; &lt;strong&gt;&amp;gt; Gradle&lt;/strong&gt;（在Mac上为&lt;strong&gt;Android Studio&amp;gt;首选项&amp;gt;实验&amp;gt; Gradle&lt;/strong&gt;），然后选中&lt;strong&gt;仅同步活动的变体&lt;/strong&gt;复选框。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：此优化完全支持包括Java和C ++语言的项目，并且对Kotlin有所支持。为具有Kotlin内容的项目启用优化时，Gradle同步会退回到内部使用完整变体的方式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;自动下载缺少的SDK软件包&lt;/strong&gt;：此功能已扩展为支持NDK。要了解更多信息，请阅读 &lt;a href=&quot;https://developer.android.com/studio/intro/update#download-with-gradle&quot;&gt;使用Gradle自动下载缺少的软件包&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bug修复-1&quot;&gt;Bug修复&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Android Gradle插件3.3.0修复了以下问题：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android.support.v8.renderscript.RenderScript&lt;/code&gt; 尽管启用了Jetifier，但构建过程将调用而不是AndroidX版本&lt;/li&gt;
      &lt;li&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;androidx-rs.jar&lt;/code&gt;包含静态捆绑 而引起的冲突&lt;code class=&quot;highlighter-rouge&quot;&gt;annotation.AnyRes&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;使用RenderScript时，您不再需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中手动设置Build Tools版本&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3202018年9月&quot;&gt;3.2.0（2018年9月）&lt;/h2&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/4.6/release-notes.html&quot;&gt;Gradle 4.6&lt;/a&gt;或更高。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分 。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;SDK Build Tools 28.0.3&lt;/a&gt;或更高版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.2.1（2018年10月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用此更新，您不再需要为SDK生成工具指定版本。Android Gradle插件现在默认使用28.0.3版本。&lt;/p&gt;

&lt;h3 id=&quot;新功能-4&quot;&gt;新功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;支持构建Android应用程序捆绑包：&lt;/strong&gt;应用程序捆绑包是一种新的上传格式，其中包括您应用程序的所有已编译代码和资源，同时推迟了APK的生成并登录到Google Play商店。您不再需要构建，签名和管理多个APK，并且用户可以获得针对其设备进行了优化的较小下载量。要了解更多信息，请阅读 &lt;a href=&quot;https://developer.android.com/guide/app-bundle&quot;&gt;关于Android应用程序捆绑包&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;使用注解处理器时提高增量编译速度支持：&lt;/strong&gt; 在&lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.AnnotationProcessorOptions.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AnnotationProcessorOptions&lt;/code&gt;&lt;/a&gt; DSL现在扩展&lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/process/CommandLineArgumentProvider.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineArgumentProvider&lt;/code&gt;&lt;/a&gt;，使您或注解处理器笔者注释参数为使用处理器 &lt;a href=&quot;https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks&quot;&gt;增量生成属性类型注释&lt;/a&gt;。使用这些注释可以提高增量和缓存的干净构建的正确性和性能。要了解更多信息，请阅读将 &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#processor-arguments&quot;&gt;参数传递给注释处理器&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用于AndroidX的迁移工具：&lt;/strong&gt;在Android 3.2和更高版本中使用Android Gradle插件3.2.0时，可以通过从菜单栏中选择“ &lt;strong&gt;重构”&amp;gt;“迁移到AndroidX”&lt;/strong&gt;，来迁移项目的本地和Maven依赖项以使用新的AndroidX库 。使用此迁移工具还将&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中设置以下标志：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android.useAndroidX&lt;/code&gt;：&lt;/strong&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;为时，Android插件将使用适当的AndroidX库而不是支持库。如果未指定此标志，则插件&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;默认将其设置为。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android.enableJetifier&lt;/code&gt;：&lt;/strong&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;为时，Android插件会通过重写二进制文件来自动迁移现有的第三方库以使用AndroidX。如果未指定此标志，则插件&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;默认将其设置为。您可以将此标志设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;仅在，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;android.useAndroidX&lt;/code&gt;还将设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，否则会出现构建错误。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;要了解更多信息，请阅读&lt;a href=&quot;https://developer.android.com/topic/libraries/support-library/androidx-overview&quot;&gt;AndroidX概述&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;新的代码收缩器R8：&lt;/strong&gt; R8是替代ProGuard的用于代码收缩和混淆的新工具。您可以通过在项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包含以下内容来开始使用R8的预览版：&lt;/p&gt;

    &lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;enableR8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;行为改变-4&quot;&gt;行为改变&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;D8的脱糖功能现在默认启用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AAPT2现在在Google的Maven回购中。要使用AAPT2，请确保文件中具有 &lt;code class=&quot;highlighter-rouge&quot;&gt;google()&lt;/code&gt;依赖项&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;，如下所示：&lt;/p&gt;

    &lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// here&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;jcenter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'com.android.tools.build:gradle:3.2.0'&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;allprojects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// and here&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;jcenter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在默认启用本机multidex。将应用程序的调试版本部署到运行Android API级别21或更高版本的设备时，早期版本的Android Studio会启用本机multidex。现在，无论您是要部署到设备上还是构建要发布的APK，Android Gradle插件均可为所有已设置&lt;code class=&quot;highlighter-rouge&quot;&gt;minSdkVersion=21&lt;/code&gt;或更高版本的模块启用本机multidex 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在，该插件将强制执行protobuf插件（0.8.6），Kotlin插件（1.2.50）和Crashlytics插件（1.25.4）的最低版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;com.android.feature&lt;/code&gt;指定模块名称时，功能模块插件现已强制仅使用字母，数字和下划线。例如，如果功能模块名称包含破折号，则会出现构建错误。此行为与动态功能模块插件的行为匹配。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bug修复-2&quot;&gt;Bug修复&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;JavaCompile现在可以在具有数据绑定的项目中缓存。（&lt;a href=&quot;https://issuetracker.google.com/69243050&quot;&gt;问题＃69243050&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;对于具有数据绑定的库模块，可以更好地避免编译。（&lt;a href=&quot;https://issuetracker.google.com/77539932&quot;&gt;问题＃77539932&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;如果由于某些不可预测的构建错误而在较早版本中将其禁用，则现在可以重新启用 &lt;a href=&quot;https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:configuration_on_demand&quot;&gt;按需配置&lt;/a&gt;。（&lt;a href=&quot;https://issuetracker.google.com/77910727&quot;&gt;问题＃77910727&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3102018年3月&quot;&gt;3.1.0（2018年3月）&lt;/h2&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/current/release-notes.html&quot;&gt;Gradle 4.4&lt;/a&gt;或更高版本。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分 。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;构建工具27.0.3&lt;/a&gt;或更高版本。请记住，您不再需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;android.buildToolsVersion&lt;/code&gt;属性为构建工具指定版本-插件默认使用最低要求版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;新的dex编译器d8&quot;&gt;新的DEX编译器D8&lt;/h3&gt;

&lt;p&gt;默认情况下，Android Studio现在使用名为D8的新DEX编译器。DEX编译是将&lt;code class=&quot;highlighter-rouge&quot;&gt;.class&lt;/code&gt; 字节码转换&lt;code class=&quot;highlighter-rouge&quot;&gt;.dex&lt;/code&gt;为适用于Android运行时（或Dalvik，适用于旧版Android）的字节码的过程。与以前的DX编译器相比，D8编译速度更快，输出的DEX文件更小，同时具有相同或更好的应用程序运行时性能。&lt;/p&gt;

&lt;p&gt;D8不应更改您日常的应用程序开发工作流程。但是，如果遇到与新编译器有关的任何问题，请 &lt;a href=&quot;https://developer.android.com/studio/report-bugs&quot;&gt;报告错误&lt;/a&gt;。您可以通过在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中包含以下内容来暂时禁用D8并使用DX ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.enableD8=false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于&lt;a href=&quot;https://developer.android.com/studio/write/java8-support&quot;&gt;使用Java 8语言功能的&lt;/a&gt;项目， 默认情况下启用增量删除。您可以通过在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中指定以下内容来禁用它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android.enableIncrementalDesugaring=false.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;预览用户：&lt;/strong&gt;如果您已经在使用D8的预览版，请注意，它现在可以根据&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools&quot;&gt;SDK生成工具（&lt;/a&gt;而非JDK）中包含的库进行编译 。因此，如果您访问的是JDK中存在的API，而不是SDK生成工具库中存在的API，则会出现编译错误。&lt;/p&gt;

&lt;h3 id=&quot;行为改变-5&quot;&gt;行为改变&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;a href=&quot;https://developer.android.com/studio/build/configure-apk-splits&quot;&gt;建立多个APK&lt;/a&gt;每个目标不同的ABI，插件不再生成的APK用于通过缺省以下的ABI： ，&lt;code class=&quot;highlighter-rouge&quot;&gt;mips&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;mips64&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;如果要构建针对这些ABI的APK，则必须使用 &lt;a href=&quot;https://developer.android.com/ndk/downloads/revision_history&quot;&gt;NDK r16b或更低版本，&lt;/a&gt;并在&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中指定ABI ，如下所示：&lt;/p&gt;

    &lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;拆分&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;abi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;包括&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'armeabi'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mips'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'mips64'&lt;/span&gt;  
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;a href=&quot;https://developer.android.com/topic/instant-apps/guides/config-splits&quot;&gt;构建配置的APK&lt;/a&gt; 为Android的即时应用，语言配置分裂正在由默认的根语言分组。例如，如果您的应用程序包含用于&lt;code class=&quot;highlighter-rouge&quot;&gt;zh-TW&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;zh-CN&lt;/code&gt;语言环境的资源，则Gradle会将这些资源打包为一种&lt;code class=&quot;highlighter-rouge&quot;&gt;zh&lt;/code&gt;语言配置拆分。您可以通过使用&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;属性定义自己的组来覆盖此行为，如下所示：&lt;/p&gt;

    &lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;splits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;language&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Each string defines a group of locales that&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Gradle should package together.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;in,id&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s2&quot;&gt;&quot;iw,he&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s2&quot;&gt;&quot;fil,tl,tgl&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;s2&quot;&gt;&quot;yue,zh,zh-TW,zh-CN&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在，Android插件的&lt;a href=&quot;https://developer.android.com/studio/build/build-cache&quot;&gt;构建缓存会&lt;/a&gt;逐出超过30天的缓存条目。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传递&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;auto&quot;&lt;/code&gt;到 &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html#com.android.build.gradle.internal.dsl.ProductFlavor:resConfig(java.lang.String)&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resConfig&lt;/code&gt;&lt;/a&gt; 不再自动选择字符串资源以打包到您的APK中。如果您继续使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;auto&quot;&lt;/code&gt;，该插件会打包您的应用及其依赖项提供的所有字符串资源。因此，您应该指定您希望插件打包到APK中的每个区域设置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于本地模块不能依赖于您应用程序的测试APK，因此使用&lt;code class=&quot;highlighter-rouge&quot;&gt;androidTestApi&lt;/code&gt; 配置（而不是）将依赖项添加到您的检测测试中&lt;code class=&quot;highlighter-rouge&quot;&gt;androidTestImplementation&lt;/code&gt;会导致Gradle发出以下警告：&lt;/p&gt;

    &lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nl&quot;&gt;WARNING:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'androidTestApi'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obsolete&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;been&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replaced&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'androidTestImplementation'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;修正&quot;&gt;修正&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;修复了Android Studio无法正确识别复合体版本中的依赖项的问题。&lt;/li&gt;
  &lt;li&gt;修复了在单个构建中多次加载Android插件时（例如，当多个子项目各自在其buildscript类路径中包含Android插件时）出现项目同步错误的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3002017年10月&quot;&gt;3.0.0（2017年10月）&lt;/h2&gt;

&lt;p&gt;Android Gradle插件3.0.0包含多种更改，旨在解决大型项目的性能问题。&lt;/p&gt;

&lt;p&gt;例如，在 具有约130个模块和大量外部依赖项（但没有代码或资源）的 &lt;a href=&quot;https://github.com/jmslau/perf-android-large.git&quot;&gt;示例框架项目中&lt;/a&gt;，您可以体验到与以下类似的性能改进：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Android插件版本+ Gradle版本&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Android插件2.2.0 + Gradle 2.14.1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Android插件2.3.0 + Gradle 3.3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Android插件3.0.0 + Gradle 4.1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;配置（例如运行）&lt;code class=&quot;highlighter-rouge&quot;&gt;./gradlew --help&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;〜2分钟&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;约9秒&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;〜2.5秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1行Java更改（实现更改）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;〜2分钟15 s&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;〜29秒&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;约6.4秒&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中一些更改会破坏现有版本。因此，在使用新插件之前，您应该考虑迁移项目的工作。&lt;/p&gt;

&lt;p&gt;如果您没有体验到上述的性能改进，请 &lt;a href=&quot;https://issuetracker.google.com/issues/new?component=192708&amp;amp;template=840533&quot;&gt;提交一个错误，&lt;/a&gt; 并使用&lt;a href=&quot;https://github.com/gradle/gradle-profiler&quot;&gt;Gradle Profiler&lt;/a&gt;跟踪您的构建 。&lt;/p&gt;

&lt;p&gt;此版本的Android插件需要满足以下条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.gradle.org/current/release-notes.html&quot;&gt;Gradle 4.1&lt;/a&gt;或更高版本。要了解更多信息，请阅读有关&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-gradle&quot;&gt;更新Gradle&lt;/a&gt;的部分 。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/releases/build-tools#notes&quot;&gt;构建工具26.0.2&lt;/a&gt;或更高版本。使用此更新，您不再需要为构建工具指定版本-插件默认使用最低要求的版本。因此，您现在可以删除该&lt;code class=&quot;highlighter-rouge&quot;&gt;android.buildToolsVersion&lt;/code&gt;属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.0.1（2017年11月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个次要更新，以支持Android Studio 3.0.1，并包括常规的错误修复和性能改进。&lt;/p&gt;

&lt;h3 id=&quot;最佳化&quot;&gt;最佳化&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过细粒度的任务图为多模块项目提供更好的并行性。&lt;/li&gt;
  &lt;li&gt;在对依赖项进行更改时，Gradle通过不重新编译无法访问该依赖项的API的模块来执行更快的构建。您应该限制其依赖通过泄露其API给其他模块 &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#dependency_configurations&quot;&gt;使用摇篮的新的相关配置&lt;/a&gt;： &lt;code class=&quot;highlighter-rouge&quot;&gt;implementation&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;api&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;compileOnly&lt;/code&gt;，和&lt;code class=&quot;highlighter-rouge&quot;&gt;runtimeOnly&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;由于每个类的分解，增量构建速度更快。现在，每个类都被编译到单独的DEX文件中，并且仅对修改后的类进行重新排序。您还应该期望将设置&lt;code class=&quot;highlighter-rouge&quot;&gt;minSdkVersion&lt;/code&gt;为20或更低并使用&lt;a href=&quot;https://developer.android.com/studio/build/multidex#mdex-pre-l&quot;&gt;旧版multi-dex的&lt;/a&gt;应用程序的构建速度提高。&lt;/li&gt;
  &lt;li&gt;通过优化某些任务以使用chached输出，提高了构建速度。要从此优化中受益，您需要首先 &lt;a href=&quot;https://docs.gradle.org/current/userguide/build_cache.html#sec:build_cache_enable&quot;&gt;启用Gradle构建缓存&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;使用AAPT2改进了增量资源处理，默认情况下已启用。如果您在使用AAPT2时遇到问题，请 &lt;a href=&quot;https://developer.android.com/studio/report-bugs&quot;&gt;报告错误&lt;/a&gt;。您还可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;android.enableAapt2=false&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中进行设置并通过&lt;code class=&quot;highlighter-rouge&quot;&gt;./gradlew --stop&lt;/code&gt;从命令行运行来重新启动Gradle守护程序来禁用AAPT2 。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;新功能-5&quot;&gt;新功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/build/dependencies#variant_aware&quot;&gt;变体感知依赖管理&lt;/a&gt;。现在，在构建模块的特定变体时，插件会自动将本地库模块依赖项的变体与要构建的模块的变体匹配。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;包括一个新的功能模块插件，以支持 &lt;a href=&quot;https://developer.android.com/topic/instant-apps&quot;&gt;Android Instant Apps&lt;/a&gt;和Android Instant Apps SDK（可以&lt;a href=&quot;https://developer.android.com/studio/intro/update#sdk-manager&quot;&gt;使用SDK管理器&lt;/a&gt;下载 ）。要了解有关使用新插件创建功能模块的更多信息，请阅读 &lt;a href=&quot;https://developer.android.com/topic/instant-apps/getting-started/structure#structure_of_an_instant_app_with_multiple_features&quot;&gt;具有多个功能的即时应用的结构&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对使用某些Java 8语言功能和Java 8库的内置支持。 &lt;strong&gt;现在已弃用Jack，不再需要它&lt;/strong&gt;，您应该首先禁用Jack以使用默认工具链中内置的改进的Java 8支持。有关更多信息，请阅读&lt;a href=&quot;https://developer.android.com/studio/write/java8-support&quot;&gt;使用Java 8语言功能&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加了对使用&lt;/p&gt;

    &lt;p&gt;Android Test Orchestrator&lt;/p&gt;

    &lt;p&gt;运行测试的支持 ，该功能使您可以在自己的调用中运行每个应用程序的测试&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Instrumentation
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;。由于每个测试都在其自己的&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Instrumentation
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;实例中运行，因此测试之间的任何共享状态都不会累积在设备的CPU或内存上。而且，即使一个测试崩溃了，它也只会删除其自己的实例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Instrumentation
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;，因此您的其他测试仍然可以运行。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;已添加&lt;code class=&quot;highlighter-rouge&quot;&gt;testOptions.execution&lt;/code&gt;以确定是否使用设备上的测试流程。如果要 &lt;a href=&quot;https://developer.android.com/training/testing/junit-runner#using-android-test-orchestrator&quot;&gt;使用Android Test Orchestrator&lt;/a&gt;，则需要指定&lt;code class=&quot;highlighter-rouge&quot;&gt;ANDROID_TEST_ORCHESTRATOR&lt;/code&gt;，如下所示。默认情况下，此属性设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;HOST&lt;/code&gt;，这将禁用设备编排，并且是运行测试的标准方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;testOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;执行“&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ANDROID_TEST_ORCHESTRATOR&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;新的&lt;code class=&quot;highlighter-rouge&quot;&gt;androidTestUtil&lt;/code&gt;依赖项配置允许您在运行检测测试之前安装另一个测试助手APK，例如Android Test Orchestrator：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;依赖项&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;androidTestUtil&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'com.android.support.test ：orchestrator：1.0.0'&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;已添加&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;testOptions.unitTests.includeAndroidResources
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;以支持需要Android资源的单元测试，例如&lt;/p&gt;

    &lt;p&gt;Roboelectric&lt;/p&gt;

    &lt;p&gt;。当您将此属性设置为时&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;，插件将在运行单元测试之前执行资源，资产和清单合并。然后，您的测试可以&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;com/android/tools/test_config.properties
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;在类路径上检查以下键：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;android_merged_assets
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;：合并资产目录的绝对路径。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对于库模块，合并的资产不包含依赖项的资产（请参阅&lt;a href=&quot;https://issuetracker.google.com/65550419&quot;&gt;问题＃65550419&lt;/a&gt;）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android_merged_manifest&lt;/code&gt;：合并清单文件的绝对路径。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android_merged_resources&lt;/code&gt;：合并资源目录的绝对路径，该目录包含模块中的所有资源及其所有依赖项。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android_custom_package&lt;/code&gt;：最终R类的包名称。如果您动态修改应用程序ID，则此程序包名称可能与&lt;code class=&quot;highlighter-rouge&quot;&gt;package&lt;/code&gt;应用程序清单中的属性不匹配。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持&lt;a href=&quot;https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml&quot;&gt;字体作为资源&lt;/a&gt; （这是&lt;a href=&quot;https://developer.android.com/about/versions/oreo&quot;&gt;Android 8.0（API级别26）中&lt;/a&gt;引入的新功能）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/instant-apps/release-notes#android_instant_apps_development_sdk_v110&quot;&gt;Android Instant Apps SDK 1.1&lt;/a&gt; 及更高版本支持特定于语言的APK 。有关更多信息，请参阅 &lt;a href=&quot;https://developer.android.com/topic/instant-apps/guides/config-splits&quot;&gt;为纯拆分配置构建&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在，您可以更改外部本机生成项目的输出目录，如下所示：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;externalNativeBuild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//对于ndk-build，请改用ndkBuild块。&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cmake&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//指定外部本机输出的相对路径&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//构建。您可以指定不是子目录的任何路径&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//项目临时构建目录的//。&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;buildStagingDirectory&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/outputs/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmake&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;现在， 从Android Studio构建本机项目时，可以&lt;a href=&quot;https://developer.android.com/studio/projects/install-ndk#vanilla_cmake&quot;&gt;使用CMake 3.7或更高&lt;/a&gt;版本。&lt;/li&gt;
  &lt;li&gt;新的&lt;code class=&quot;highlighter-rouge&quot;&gt;lintChecks&lt;/code&gt;依赖项配置允许您构建定义自定义棉绒规则的JAR，并将其打包到AAR和APK项目中。您的自定义棉绒规则必须属于一个单独的项目，该项目输出一个JAR，并且仅包含 &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;compileOnly&lt;/code&gt;&lt;/a&gt; 依赖项。然后，其他应用程序和库模块可以使用以下&lt;code class=&quot;highlighter-rouge&quot;&gt;lintChecks&lt;/code&gt;配置依赖于您的lint项目：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;依赖项&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//这告诉Gradle插件将'：lint-checks'构建到lint.jar文件中&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//并将其与您的模块打包。如果模块是Android库，&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//其他依赖它的项目会自动使用lint检查。&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//如果模块是应用程序，则分析应用程序时，lint会包含以下规则。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lintChecks&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;项目（&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'：lint-checks'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;行为改变-6&quot;&gt;行为改变&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Android插件3.0.0删除了某些API，如果使用它们，构建会中断。例如，您不能再使用Variants API来访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;outputFile()&lt;/code&gt;对象或用于&lt;code class=&quot;highlighter-rouge&quot;&gt;processManifest.manifestOutputFile()&lt;/code&gt;获取每个变量的清单文件。要了解更多信息，请阅读 &lt;a href=&quot;https://developer.android.com/studio/known-issues#variant_api&quot;&gt;API更改&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;您不再需要为构建工具指定版本（因此，您现在可以删除该&lt;code class=&quot;highlighter-rouge&quot;&gt;android.buildToolsVersion&lt;/code&gt;属性）。默认情况下，该插件会自动使用您所使用的Android插件版本所需的最低构建工具版本。&lt;/li&gt;
  &lt;li&gt;现在，您可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;buildTypes&lt;/code&gt;块中启用/禁用PNG压缩，如下所示。默认情况下，除调试版本外，所有版本均启用PNG压缩，因为它会增加包含许多PNG文件的项目的生成时间。因此，要缩短其他构建类型的构建时间，应禁用PNG压缩或 &lt;a href=&quot;https://developer.android.com/studio/write/convert-webp#convert_images_to_webp&quot;&gt;将图像转换为WebP&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;buildTypes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;发布&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//禁用发布版本类型的PNG处理。&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;crunchPngs&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;错误&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;现在，Android插件会自动构建您在外部CMake项目中配置的可执行目标。&lt;/li&gt;
  &lt;li&gt;现在，您必须 使用依赖项配置&lt;a href=&quot;https://developer.android.com/studio/build/dependencies#annotation_processor&quot;&gt;将注释处理器添加&lt;/a&gt;到处理器类路径&lt;code class=&quot;highlighter-rouge&quot;&gt;annotationProcessor&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ndkCompile&lt;/code&gt;现在不建议使用已弃用的软件。相反，您应该迁移到使用CMake或ndk-build来编译要打包到APK中的本机代码。要了解更多信息，请阅读 &lt;a href=&quot;https://developer.android.com/studio/projects/add-native-code#ndkCompile&quot;&gt;从ndkcompile迁移&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2302017年2月&quot;&gt;2.3.0（2017年2月）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;2.3.3（2017年6月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个次要更新，增加了与&lt;a href=&quot;https://developer.android.com/studio/releases#Revisions&quot;&gt;Android Studio 2.3.3的&lt;/a&gt;兼容性 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.2（2017年5月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个次要更新，增加了与&lt;a href=&quot;https://developer.android.com/studio/releases#Revisions&quot;&gt;Android Studio 2.3.2的&lt;/a&gt;兼容性 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1（2017年4月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是对Android插件2.3.0的次要更新，修正了一些物理Android设备无法在&lt;a href=&quot;https://developer.android.com/studio/run#instant-run&quot;&gt; Instant Run上&lt;/a&gt;正常&lt;a href=&quot;https://developer.android.com/studio/run#instant-run&quot;&gt;运行的问题&lt;/a&gt;（请参见&lt;a href=&quot;https://code.google.com/p/android/issues/detail?id=235879&quot;&gt; Issue＃235879&lt;/a&gt;）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;依存关系：&lt;/p&gt;

    &lt;p&gt;Gradle 3.3或更高版本。&lt;a href=&quot;https://developer.android.com/tools/revisions/build-tools&quot;&gt;构建工具25.0.0&lt;/a&gt; 或更高版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新：&lt;/p&gt;

    &lt;p&gt;使用Gradle 3.3，其中包括性能改进和新功能。有关更多详细信息，请参见&lt;a href=&quot;https://docs.gradle.org/3.3/release-notes&quot;&gt;Gradle发行说明&lt;/a&gt;。&lt;strong&gt;构建缓存&lt;/strong&gt;：存储构建项目时Android插件生成的某些输出（例如未打包的AAR和预先定义的远程依赖项）。使用缓存时，您的干净构建速度要快得多，因为构建系统可以在后续构建过程中简单地重用那些缓存的文件，而不用重新创建它们。使用Android插件2.3.0及更高版本的项目默认情况下使用构建缓存。要了解更多信息，请阅读“ &lt;a href=&quot;https://developer.android.com/studio/build/build-cache&quot;&gt;使用构建缓存提高构建速度”&lt;/a&gt;。包括&lt;a href=&quot;https://developer.android.com/studio/build/build-cache#clear_the_build_cache&quot;&gt;清除构建缓存&lt;/a&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;cleanBuildCache&lt;/code&gt;任务。如果您正在使用实验版本的构建缓存（包含在该插件的早期版本中），则应&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin#updating-plugin&quot;&gt;将您的插件更新&lt;/a&gt;为最新版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变化：&lt;/p&gt;

    &lt;p&gt;支持对&lt;a href=&quot;https://developer.android.com/studio/releases&quot;&gt;Android Studio 2.3中&lt;/a&gt;包含的Instant Run的更改。大型项目的配置时间应该明显更快。修复了&lt;a href=&quot;https://developer.android.com/training/constraint-layout&quot;&gt;约束布局库&lt;/a&gt;自动下载的问题。插件现在使用&lt;a href=&quot;https://www.guardsquare.com/en/proguard/manual/versions&quot;&gt;ProGuard版本5.3.2&lt;/a&gt;。包括许多已&lt;a href=&quot;https://code.google.com/p/android/issues/list?can=1&amp;amp;q=Component%3DTools++Subcomponent%3DTools-gradle%2CTools-build%2CTools-instantrun%2CTools-cpp-build+Target%3D2.3+status%3AFutureRelease%2CReleased+&amp;amp;sort=priority+-status&amp;amp;colspec=ID+Status+Priority+Owner+Summary+Stars+Reporter+Opened&amp;amp;cells=tiles&quot;&gt; 报告错误的&lt;/a&gt;修复程序。遇到问题时，请继续&lt;a href=&quot;https://developer.android.com/studio/report-bugs&quot;&gt;提交错误报告&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2202016年9月&quot;&gt;2.2.0（2016年9月）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;依存关系：&lt;/p&gt;

    &lt;p&gt;Gradle 2.14.1或更高版本。&lt;a href=&quot;https://developer.android.com/tools/revisions/build-tools&quot;&gt;构建工具23.0.2&lt;/a&gt; 或更高版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新：&lt;/p&gt;

    &lt;p&gt;使用Gradle 2.14.1，其中包括性能改进和新功能，并修复了一个安全漏洞，该漏洞可在使用Gradle守护程序时允许本地特权升级。有关更多详细信息，请参见&lt;a href=&quot;https://docs.gradle.org/2.14.1/release-notes&quot;&gt; Gradle发行说明&lt;/a&gt;。使用DSL，Gradle现在可让您链接到本机源，并使用CMake或ndk-build编译本机库。构建本机库后，Gradle将它们打包到您的APK中。要了解有关将CMake和ndk-build与Gradle结合使用的更多信息，请阅读&lt;a href=&quot;https://developer.android.com/studio/projects/add-native-code&quot;&gt;向项目添加C和C ++代码&lt;/a&gt;。 &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ExternalNativeBuild.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;externalNativeBuild {}&lt;/code&gt;&lt;/a&gt;当您&lt;a href=&quot;https://developer.android.com/studio/build/building-cmdline&quot;&gt;从命令行运行构建时&lt;/a&gt;，Gradle现在尝试自动下载项目依赖的所有缺少的SDK组件或更新。要了解更多信息，请阅读&lt;a href=&quot;https://developer.android.com/studio/intro/update#download-with-gradle&quot;&gt;使用Gradle自动下载缺少的软件包&lt;/a&gt;。一项新的实验性缓存功能使Gradle通过预删除，存储和重新使用库的预删除版本来加快构建时间。要了解有关使用此实验功能的更多信息，请阅读&lt;a href=&quot;https://developer.android.com/studio/build/build-cache&quot;&gt;Build Cache&lt;/a&gt;指南。通过采用新的默认打包管道来提高构建性能，该默认打包管道可在一项任务中处理&lt;a href=&quot;https://developer.android.com/studio/command-line/zipalign&quot;&gt;zip&lt;/a&gt;，签名和&lt;a href=&quot;https://developer.android.com/studio/command-line/zipalign&quot;&gt;zipaligning&lt;/a&gt;。您可以通过添加&lt;code class=&quot;highlighter-rouge&quot;&gt;android.useOldPackaging=true&lt;/code&gt;到 &lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中恢复使用较旧的打包工具 。使用新的打包工具时，该&lt;code class=&quot;highlighter-rouge&quot;&gt;zipalignDebug&lt;/code&gt;任务不可用。但是，您可以通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;createZipAlignTask(String taskName, File inputFile, File outputFile)&lt;/code&gt;方法自己创建一个 。现在，除了传统的JAR签名外，APK签名还使用&lt;a href=&quot;https://developer.android.com/about/versions/nougat/android-7.0#apk_signature_v2&quot;&gt;APK签名方案v2&lt;/a&gt;。所有Android平台均接受生成的APK。签名后对这些APK进行的任何修改都会使其v2签名无效，并阻止在设备上安装。要禁用此功能，请将以下内容添加到模块级&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中：&lt;code class=&quot;highlighter-rouge&quot;&gt;android { ... signingConfigs {  配置{   ...   v2SigningEnabled false  } }}&lt;/code&gt;对于multidex构建，您现在可以使用ProGuard规则来确定Gradle应将哪些类编译到应用程序的&lt;em&gt;主&lt;/em&gt; DEX文件中。因为Android系统在启动应用程序时会首先加载主DEX文件，所以您可以在启动时通过将某些类编译为主DEX文件来对它们进行优先级排序。在专门为您的主DEX文件创建ProGuard配置文件后，请使用将配置文件的路径传递到Gradle &lt;code class=&quot;highlighter-rouge&quot;&gt;buildTypes.multiDexKeepProguard&lt;/code&gt;。使用此DSL与使用DSL不同，后者使用DSL 为您的应用程序提供常规的ProGuard规则，而不为主DEX文件指定类。 &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html#com.android.build.gradle.internal.dsl.BuildType:proguardFiles(java.lang.Object[])&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildTypes.proguardFiles&lt;/code&gt;&lt;/a&gt;添加了对该&lt;code class=&quot;highlighter-rouge&quot;&gt;android:extractNativeLibs&lt;/code&gt;标志的支持，可以在将应用程序安装到设备上时减小其大小。当您&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;在 &lt;a href=&quot;https://developer.android.com/guide/topics/manifest/application-element&quot;&gt;``&lt;/a&gt; 应用清单元素中将此标志设置为时，Gradle会将原生库的未压缩版本和对齐版本与APK打包在一起。这样可以防止&lt;a href=&quot;https://developer.android.com/reference/android/content/pm/PackageManager&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PackageManager&lt;/code&gt;&lt;/a&gt; 在安装过程中将本机库从APK复制到设备的文件系统中，并具有使应用程序的增量更新变小的额外好处。现在，您可以指定和用于产品口味。（&lt;a href=&quot;http://b.android.com/59614&quot;&gt;问题59614&lt;/a&gt;） &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html#com.android.build.gradle.internal.dsl.ProductFlavor:versionNameSuffix&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;versionNameSuffix&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html#com.android.build.gradle.internal.dsl.ProductFlavor:applicationIdSuffix&quot;&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;applicationIdSuffix&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变化：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultProguardFile&lt;/code&gt; 现在返回用于Gradle的Android插件提供的默认ProGuard文件，并且不再使用Android SDK中的文件。改进的Jack编译器性能和功能：杰克现在支持Jacoco测试范围设定时 &lt;code class=&quot;highlighter-rouge&quot;&gt;testCoverageEnabled&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。改进了对注释处理器的支持。类路径上的注释处理器（例如所有&lt;code class=&quot;highlighter-rouge&quot;&gt;compile&lt;/code&gt; 依赖项）将自动应用于构建。您还可以在构建中指定注释处理器，并通过使用模块级文件中的DSL来传递参数： &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.AnnotationProcessorOptions.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javaCompileOptions.annotationProcessorOptions {}&lt;/code&gt;&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android { ... defaultConfig {  ...  javaCompileOptions {   注解ProcessorOptions {    className'com.example.MyProcessor '    //参数是可选的。    arguments = [ foo ：'bar' ]      }  } }}&lt;/code&gt;如果要在编译时应用注释处理器但不将其包含在APK中，请使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;annotationProcessor&lt;/code&gt;依赖项范围：&lt;code class=&quot;highlighter-rouge&quot;&gt;依赖项{  编译'com.google.dagger：dagger：2.0'  注解处理器'com.google.dagger：dagger-compiler：2.0'  //或使用buildVariantAnnotationProcessor定位特定的构建变体}&lt;/code&gt;您可以使用来为Jack设置其他标志。以下代码段将参数设置为： &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.JackOptions.html#com.android.build.gradle.internal.dsl.JackOptions:additionalParameters&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jackOptions.additionalParameters()&lt;/code&gt;&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jack.incremental&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android { defaultConfig {  ...  jackOptions {   启用true   additionalParameters （“jack.incremental” ：真）    } }}&lt;/code&gt;有关可以设置的参数的列表，请从命令行运行以下命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;java -jar /build-tools/jack.jar --help-properties &lt;/code&gt;默认情况下，如果Gradle守护程序的堆大小至少为1.5 GB，则Jack现在将在与Gradle相同的进程中运行。要调整守护程序堆大小，请在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中添加以下内容 ：&lt;code class=&quot;highlighter-rouge&quot;&gt;＃将守护程序堆大小设置为1.5GB。 org.gradle.jvmargs = -Xmx1536M &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2102016年4月&quot;&gt;2.1.0（2016年4月）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;2.1.3（2016年8月）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此更新要求Gradle 2.14.1及更高版本。Gradle 2.14.1包括性能改进，新功能和重要的&lt;a href=&quot;https://docs.gradle.org/2.14/release-notes#local-privilege-escalation-when-using-the-daemon&quot;&gt;安全修复程序&lt;/a&gt;。有关更多详细信息，请参见 &lt;a href=&quot;https://docs.gradle.org/2.14.1/release-notes&quot;&gt;Gradle发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;依存关系：&lt;/p&gt;

    &lt;p&gt;Gradle 2.10或更高版本。&lt;a href=&quot;https://developer.android.com/tools/revisions/build-tools&quot;&gt;构建工具23.0.2&lt;/a&gt; 或更高版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新：&lt;/p&gt;

    &lt;p&gt;使用Jack工具链增加了对N Developer Preview，JDK 8和&lt;a href=&quot;https://developer.android.com/preview/j8-jack&quot;&gt;Java 8语言功能&lt;/a&gt;的支持。要了解更多信息，请阅读《&lt;a href=&quot;https://developer.android.com/preview/overview&quot;&gt;N预览指南》&lt;/a&gt;。&lt;strong&gt;注意：&lt;/strong&gt; &lt;a href=&quot;https://developer.android.com/tools/building/building-studio#instant-run&quot;&gt;Instant Run&lt;/a&gt;当前不适用于Jack，在使用新工具链时将被禁用。如果您正在开发N预览版并且想要使用受支持的Java 8语言功能，则仅需要使用Jack。添加了对增量Java编译的默认支持，以减少开发过程中的编译时间。它仅通过重新编译源代码中已更改或需要重新编译的部分来执行此操作。要禁用此功能，请将以下代码添加到模块级 &lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中：&lt;code class=&quot;highlighter-rouge&quot;&gt;android { ... compileOptions {  增量错误 }}&lt;/code&gt;增加了对进行中脱胶的支持，该功能可在构建过程中而不是在单独的外部VM进程中执行脱色。这不仅使增量构建更快，而且加快了完整构建。对于已将Gradle守护程序的最大堆大小设置为至少2048 MB的项目，默认情况下启用此功能。您可以通过在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;文件中添加以下内容来实现：&lt;code class=&quot;highlighter-rouge&quot;&gt;org 。摇篮。jvmargs = - Xmx2048m &lt;/code&gt;如果您在模块级 文件中定义了的值，则需要将其设置为 + 1024 MB。例如，如果您设置 为“ 2048m”，则需要在项目文件中添加以下内容： &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.DexOptions.html#com.android.build.gradle.internal.dsl.DexOptions:javaMaxHeapSize&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javaMaxHeapSize&lt;/code&gt;&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.gradle.jvmargs&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javaMaxHeapSize&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javaMaxHeapSize&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gradle.properties&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org 。摇篮。jvmargs = - Xmx3072m &lt;/code&gt;要禁用进程中的删除，请将以下代码添加到模块级&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中：&lt;code class=&quot;highlighter-rouge&quot;&gt;android { ... dexOptions {   dexInProcess false }}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2002016年4月&quot;&gt;2.0.0（2016年4月）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;依存关系：&lt;/p&gt;

    &lt;p&gt;Gradle 2.10或更高版本。&lt;a href=&quot;https://developer.android.com/tools/revisions/build-tools&quot;&gt;构建工具21.1.1&lt;/a&gt; 或更高版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新：&lt;/p&gt;

    &lt;p&gt;通过支持字节码注入并将代码和资源更新推送到仿真器或物理设备上正在运行的应用程序，来启用&lt;a href=&quot;https://developer.android.com/tools/building/building-studio#instant-run&quot;&gt;即时运行&lt;/a&gt;。添加了对增量构建的支持，即使该应用未运行也是如此。通过将增量更改通过&lt;a href=&quot;https://developer.android.com/tools/help/adb&quot;&gt;Android调试桥&lt;/a&gt;推送到连接的设备，可以缩短完整的构建时间 。添加以控制可以同时产生多少个从属dex进程。模块级文件中的以下代码 将并发进程的最大数量设置为4： &lt;a href=&quot;https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.DexOptions.html#com.android.build.gradle.internal.dsl.DexOptions:maxProcessCount&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;maxProcessCount&lt;/code&gt;&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android { ... dexOptions {  maxProcessCount = 4 //这是默认值   }}&lt;/code&gt;添加了实验性代码收缩器以支持预删除和减少依赖项的重新删除，而Proguard不支持。这样可以提高调试构建变体的构建速度。由于实验性收缩器不支持优化和模糊处理，因此应为发布版本启用Proguard。要为调试版本启用实验性收缩器，请将以下内容添加到模块级&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;文件中：&lt;code class=&quot;highlighter-rouge&quot;&gt;android { ... buildTypes {  调试{   minifyEnabled 是   useProguard 假  }  发布{   minifyEnabled 是   useProguard true //这是默认设置   } }}&lt;/code&gt;添加了日志记录支持并提高了资源缩减器的性能。现在，资源缩减器将其所有操作记录到&lt;code class=&quot;highlighter-rouge&quot;&gt;resources.txt&lt;/code&gt; 与Proguard日志文件位于同一文件夹中的文件中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更改的行为：&lt;/p&gt;

    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;minSdkVersion&lt;/code&gt;设置为18或更高，APK签约使用SHA256。DSA和ECDSA密钥现在可以对APK软件包进行签名。&lt;strong&gt;注：&lt;/strong&gt;在&lt;a href=&quot;https://developer.android.com/training/articles/keystore&quot;&gt;Android的密钥存储&lt;/a&gt;提供商不再支持&lt;a href=&quot;https://developer.android.com/about/versions/marshmallow/android-6.0-changes#behavior-keystore&quot;&gt; 在Android 6.0 DSA密钥&lt;/a&gt;（API等级23）和更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解决的问题：&lt;/p&gt;

    &lt;p&gt;修复了导致测试和主要构建配置中重复的AAR依赖关系的问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 28 Jul 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/07/28/Android-Gradle%E6%8F%92%E4%BB%B6%E5%8F%91%E8%A1%8C%E8%AF%B4%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/07/28/Android-Gradle%E6%8F%92%E4%BB%B6%E5%8F%91%E8%A1%8C%E8%AF%B4%E6%98%8E/</guid>
        
        <category>技术</category>
        
        <category>Android</category>
        
        <category>开发</category>
        
        
      </item>
    
      <item>
        <title>print as pdf file on a mac</title>
        <description>&lt;h1 id=&quot;在mac上如何将文件打印为pdf&quot;&gt;在Mac上如何将文件打印为PDF&lt;/h1&gt;

&lt;p&gt;Mac OS X相比较其它的操作系统，其中一个优势在于它在系统级别直接内置了PDF创建功能，也就是不需要任何额外软件就可以直接将文件转换为Adobe PDF格式。系统启动后，默认就已经支持PDF打开、预览以及“打印”的功能，并且和Windows系统中的Adobe Reader不一样，在Mac中打开PDF速度非常之快。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/pinrtpdf/save_as_pdf.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（译者注：Linux操作系统例如Ubuntu等中也均内置了系统级的功能，Windows 10中也内置了PDF创建的功能，至于Windows中用Adobe Reader打开PDF比较慢，这锅微软不背，叫Adobe Reader背）&lt;/p&gt;

&lt;p&gt;另外在Mac中任何软件，只有它支持打印，都可以在打印预览窗口中找到一个“PDF”按钮，利用它可以快速创建PDF文档，具体步骤如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/printpdf/print_setting.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1、打开文 件菜单，选择打印（或者也可以按快捷键 Command + P）
 2、选择打印窗口中左侧的 PDF按钮，选择“另存为PDF”。
 3、选择你需要保存的路径，设置文件的名称
 4、完成&lt;/p&gt;

&lt;p&gt;在完成上述操作的时候，你不需要在电脑安装物理打印机，也不需要安装其它第三方的虚拟打印机驱动。对于大多数用户而言，这一功能创建PDF绰绰有余，当然如果你需要更多高级的PDF特性，就需要借助Adobe Acrobat Pro这样的专业软件了。&lt;/p&gt;

&lt;p&gt;翻译自：Mac Tips，&lt;a href=&quot;http://www.mactip.net/print-as-pdf-file-on-a-mac/&quot;&gt;http://www.mactip.net/print-as-pdf-file-on-a-mac/&lt;/a&gt;，Last updated 24th October, 2017, 8:00 PM&lt;/p&gt;

</description>
        <pubDate>Tue, 30 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/30/Export-pdf-file-in-Mac-when-Print/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/30/Export-pdf-file-in-Mac-when-Print/</guid>
        
        <category>Mac</category>
        
        
      </item>
    
      <item>
        <title>Objective-C属性(property)的特性(attribute)</title>
        <description>&lt;p&gt;先以一图总结：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200610133818.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Atttributes&lt;/p&gt;

&lt;p&gt;以下：「attribute(s)」，「特性」是指同一事物(都指&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;后面括号内的单词)。&lt;/p&gt;

&lt;p&gt;用Objective-C做过开发的朋友都知道，类里面的属性(可以近似地理解为类的变量)是用&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;关键字定义的，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;后面的括号，会写上若干「特性(attribute)」，后面跟数据类型、属性名称。如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (copy, nonatomic) NSString *name;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;写OC良久，对括号内的这些attributes，还是一知半解、不知其然，亦不知其所以然。用的时候就照葫芦画瓢。&lt;/p&gt;

&lt;p&gt;现在大伙儿慢慢转向苹果的新开发语言Swift，似乎亦不必花太多时间在Objective-C上。&lt;/p&gt;

&lt;p&gt;不过那种一知半解，不明就里的感觉，有点如鲠在喉，不甚舒服，所以花了点时间，research了一番：&lt;/p&gt;

&lt;h2 id=&quot;为什么要有property&quot;&gt;为什么要有@property？&lt;/h2&gt;

&lt;p&gt;要搞清楚「特性」，先搞清楚&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;，为什么要有&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;？&lt;/p&gt;

&lt;p&gt;在2006年的WWDC大会上，苹果发布了Objective-C 2.0，其中就包括&lt;strong&gt;&lt;a href=&quot;https://link.jianshu.com?t=https://en.wikipedia.org/wiki/Objective-C#Properties&quot;&gt;Properties&lt;/a&gt;&lt;/strong&gt;这个新的语法，把原来的实例变量定义成&lt;strong&gt;Properties(属性)&lt;/strong&gt;。这个变化，和以前相比，有什么变化呢？&lt;/p&gt;

&lt;h3 id=&quot;objective-c20之前&quot;&gt;Objective-C2.0之前:&lt;/h3&gt;

&lt;p&gt;没有Properties之前，定义实例变量，是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@interface Person : NSObject {
@public
    NSString *name;
@private
    int age;
}
@end

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在.h文件，声明setter和getter方法(setter和getter统称「accessors/存取器/访问器」)，再在.m文件实现setter和getter，这样就可以封装起来，供其他类访问(取值、赋值)了。&lt;/p&gt;

&lt;p&gt;然而，即使不使用setter和getter，其他类也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt;来直接访问，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; personA-&amp;gt;name = @&quot;123&quot;;

 NSLog(@&quot;personA-&amp;gt;name:%@&quot;, personA-&amp;gt;name);

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;为什么要getter和setter&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那么，为什么还要如此麻烦地声明和实现setter和getter呢？主要基于三个原因(参考:&lt;a href=&quot;https://link.jianshu.com?t=https://stackoverflow.com/questions/10425827/please-explain-getter-and-setters-in-objective-c&quot;&gt;Please explain Getter and Setters in Objective C&lt;/a&gt;)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以在getter和setter中添加额外的代码，实现特定的目的。比如赋值前(set)需要实现一些特定的内部计算，或者更新状态，缓存数据等等。&lt;/li&gt;
  &lt;li&gt;KVC和KVO都是基于此实现的。&lt;/li&gt;
  &lt;li&gt;在非ARC时代，可以在在getter和setter中进行内存管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，写getter和setter，可算是Objective-C中「约定俗成」的做法了。（Swift有类似的「Computed Properties/计算属性」）&lt;/p&gt;

&lt;p&gt;所以，在没有&lt;strong&gt;Objective-C2.0&lt;/strong&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;之前，我们几乎需要为所有的实例变量，手动写getter和setter——听听就觉得很可怕，对不对？&lt;/p&gt;

&lt;h3 id=&quot;objective-c20之后&quot;&gt;Objective-C2.0之后:&lt;/h3&gt;

&lt;p&gt;庆幸的是，程序员都喜欢「偷懒」，所以就有了2006年Objective-C2.0中的新语法：&lt;strong&gt;Properties&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;它帮我们自动生成getter和setter&lt;/strong&gt;(声明方法，并实现方法。当然，这部分代码并不会出现在你的项目中，是隐藏起来的)。&lt;/p&gt;

&lt;p&gt;不过，&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;的写法，也经过数次变迁(新旧写法混在一起，就更让人困惑了)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最开始，需要作3件事情：
    &lt;ul&gt;
      &lt;li&gt;在.h文件，我们用&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;声明了属性——这只是帮我们在声明了getter和setter；&lt;/li&gt;
      &lt;li&gt;还需要手动声明实例变量(和Objective-C2.0之前一样)&lt;/li&gt;
      &lt;li&gt;然后在.m文件，还要用&lt;code class=&quot;highlighter-rouge&quot;&gt;@synthesize&lt;/code&gt;自动合成getter和setter的实现。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后来，不需要为属性声明实例变量了，&lt;code class=&quot;highlighter-rouge&quot;&gt;@synthesize&lt;/code&gt;会默认自动生成一个「下划线+属性名」的实例变量。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (copy, nonatomic) NSString *name;&lt;/code&gt;之后，就可以直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;_name&lt;/code&gt;这个变量了。&lt;/li&gt;
  &lt;li&gt;再后来(Xcode4.5开始)，&lt;code class=&quot;highlighter-rouge&quot;&gt;@synthesize&lt;/code&gt;也不需要了。一个&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;搞定。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，现在我们写&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;声明属性，其实是做了三件事&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.h: 声明了getter和setter方法；&lt;/li&gt;
  &lt;li&gt;.h: 声明了实例变量(默认:下划线+属性名)；&lt;/li&gt;
  &lt;li&gt;.m: 实现了getter和setter方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;为我们所做的事情。&lt;/p&gt;

&lt;p&gt;知道它为我们做了什么，自然也就能回答：「为什么要有&lt;code class=&quot;highlighter-rouge&quot;&gt;@property&lt;/code&gt;？」这个问题了。&lt;/p&gt;

&lt;h2 id=&quot;property后面的括号又是怎么回事&quot;&gt;@property后面的括号又是怎么回事？&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (copy, nonatomic) NSString *name;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这种写法，大家肯定都写过，不过，后面跟着的这个括号又是什么玩意儿呢？&lt;/p&gt;

&lt;p&gt;官方把括号里面的东西，叫做「attribute/特性」。&lt;/p&gt;

&lt;p&gt;先试一下，把括号里的两个单词都删掉，你会发现，还能正常工作。而事实上，以下两种写法，是等价的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@property () NSString *name;// 或者@property NSString *name;
@property (atomic, strong, readwrite) NSString *name;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为attribute主要有三种类型(实际上最多可以写6个特性，后面详述)，每种类型都有默认值。如果什么都不写，系统就会取用默认值（看看，苹果良苦用心，偷偷帮我们做了那么多事情）。&lt;/p&gt;

&lt;p&gt;如上所述，attributes有三种类型：&lt;/p&gt;

&lt;h3 id=&quot;1atomicity原子性&quot;&gt;1.Atomicity(原子性)&lt;/h3&gt;

&lt;p&gt;比较简单的一句话理解就是：是否给setter和getter加锁(是否保证setter或者getter的每次访问是完整性的)。&lt;/p&gt;

&lt;p&gt;原子性，有atomic和nonatomic两个值可选。默认值是atomic(也就是不写的话，默认是atomic)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;atomic&lt;/strong&gt;(默认值)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用atomic，在一定程度上可以保证线程安全，「atomic的作用只是给getter和setter加了个锁」。也就是说，有线程在访问setter，其他线程只能等待完成后才能访问。&lt;/p&gt;

&lt;p&gt;它能保证：即使多个线程「同时」访问这个变量，atomic会让你得到一个有意义的值(valid value)。但是不能保证你获得的是哪个值（有可能是被其他线程修改过的值，也有可能是没有修改过的值）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;nonatomic&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而用nonatomic，则不保证你获得的是有效值，如果像上面所述，读、写两个线程同时访问变量，有可能会给出一个无意义的垃圾值。&lt;/p&gt;

&lt;p&gt;这样对比，atomic就显得比较鸡肋了，因为它并不能完全保证程序层面的线程安全，又有额外的性能耗费(要对getter和setter进行加锁操作，我验证过，在某个小项目中将所有的nonatomic删除，内存占用平均升高1M左右)。&lt;/p&gt;

&lt;p&gt;所以，你会见到，几乎所有情况，我们都用nonatomic。&lt;/p&gt;

&lt;h3 id=&quot;2access存取特性&quot;&gt;2.Access(存取特性)&lt;/h3&gt;

&lt;p&gt;存取特性有&lt;strong&gt;readwrite&lt;/strong&gt;(默认值)和&lt;strong&gt;readonly&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这个从名字看就很容易理解，定义了这个属性是「只读」，还是「读写」皆可。&lt;/p&gt;

&lt;p&gt;如果是&lt;strong&gt;readwrite&lt;/strong&gt;，就是告诉编译器，同时生成getter和setter。如果是&lt;strong&gt;readonly&lt;/strong&gt;，只生成getter。&lt;/p&gt;

&lt;h3 id=&quot;3storage内存管理特性管理对象的生命周期的&quot;&gt;3.Storage(内存管理特性)(管理对象的生命周期的)&lt;/h3&gt;

&lt;p&gt;最常用到&lt;strong&gt;strong&lt;/strong&gt;、&lt;strong&gt;weak&lt;/strong&gt;、&lt;strong&gt;assign&lt;/strong&gt;、&lt;strong&gt;copy&lt;/strong&gt;4个attributes。（还有一个&lt;strong&gt;retain&lt;/strong&gt;，不怎么用了）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;strong&lt;/strong&gt; (默认值)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARC新增的特性。&lt;/p&gt;

&lt;p&gt;表明你需要引用(持有)这个对象(reference to the object)，负责保持这个对象的生命周期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意，基本数据类型(非对象类型,如int, float, BOOL)，默认值并不是strong，strong只能用于对象类型。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;weak&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARC新增的特性。&lt;/p&gt;

&lt;p&gt;也会给你一个引用(reference/pointer)，指向对象。但是不会主张所有权(claim ownership)。也不会增加retain count。&lt;/p&gt;

&lt;p&gt;如果对象A被销毁，所有指向对象A的弱引用(weak reference)(用weak修饰的属性)，都会自动设置为nil。&lt;/p&gt;

&lt;p&gt;在delegate patterns中常用weak解决strong reference cycles(以前叫retain cycles)问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;copy&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了说明&lt;strong&gt;copy&lt;/strong&gt;，我们先举个栗子：&lt;/p&gt;

&lt;p&gt;我在某个类(class1)中声明两个字符串属性，一个用copy，一个不用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@property (copy, nonatomic) NSString *nameCopy;

// 或者可以省略strong, 编译器默认取用strong
@property (strong, nonatomic) NSString *nameNonCopy;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在另一个类中，用一个NSMutableString对这两个属性赋值并打印，再修改这个NSMutableString，再打印，看看会发生什么：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Class1 *testClass1 = [[Class1 alloc] init];

NSMutableString *nameString = [NSMutableString  stringWithFormat:@&quot;Antony&quot;];

// 用赋值NSMutableString给NSString赋值
testClass1.nameCopy = nameString;
testClass1.nameNonCopy = nameString;

NSLog(@&quot;修改nameString前, nameCopy: %@; nameNonCopy: %@&quot;, testClass1.nameCopy, testClass1.nameNonCopy);

[nameString appendString:@&quot;.Wong&quot;];

NSLog(@&quot;修改nameString后, nameCopy: %@; nameNonCopy: %@&quot;, testClass1.nameCopy, testClass1.nameNonCopy);

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印结果是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;修改nameString前, nameCopy: Antony; nameNonCopy: Antony
修改nameString后, nameCopy: Antony; nameNonCopy: Antony.Wong

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我只是修改了&lt;code class=&quot;highlighter-rouge&quot;&gt;nameString&lt;/code&gt;，为什么&lt;code class=&quot;highlighter-rouge&quot;&gt;testClass1.nameNonCopy&lt;/code&gt;的值没改，它也跟着变了？&lt;/p&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;特性，对对象进行引用计数加1，只是对指向对象的指针进行引用计数加1，这时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;nameString&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;testClass1.nameNonCopy&lt;/code&gt;指向的其实是同一个对象(同一块内存)，&lt;code class=&quot;highlighter-rouge&quot;&gt;nameString&lt;/code&gt;修改了值，自然影响到&lt;code class=&quot;highlighter-rouge&quot;&gt;testClass1.nameNonCopy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;这个特性，会在赋值前，复制一个对象，&lt;code class=&quot;highlighter-rouge&quot;&gt;testClass1.nameCopy&lt;/code&gt;指向了一个新对象，这时候&lt;code class=&quot;highlighter-rouge&quot;&gt;nameString&lt;/code&gt;怎么修改，也不关它啥事了。应用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;特性，系统应该是在setter中进行了如下操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- (void)setNameCopy:(NSString *)nameCopy {
    _nameCopy = [nameCopy copy];
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大家了解&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;的作用了吧，是为了防止属性被意外修改的。那什么时候要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;所有有mutable(可变)版本的属性类型，如NSString, NSArray, NSDictionary等等——他们都有可变的版本类型:NSMutableString, NSMutableArray, NSMutableDictionary。这些类型在属性赋值时，右边的值有可能是它们的可变版本。这样就会出现属性值被意外改变的可能。所以它们都应该用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果不用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;，而是在赋值前，调用copy方法，可以达到同样的目的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 这时候也可以确保nameNonCopy不会被意外修改
testClass1.nameNonCopy = [nameString copy];

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;如果用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;修饰NSMutableString、NSMutableArray会发生什么?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;修饰NSMutableString，在赋值的时候会报如下警告：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Incompatible pointer types assigning to 'NSMutableString *' from 'NSString *'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而如果用&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;修饰NSMutableArray，则在调用addObject:时直接crash：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reason: '-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x1700045c0'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果理解了「&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;特性，就是在setter中，进行了copy操作」，就很容易知道以上报错的原因：属性在赋值时，调用setter，已经将原本mutable的对象，copy成了immutable的对象(NSMutableString变成NSString，NSMutableArray变成NSArray)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;assign&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是非ARC时代的特性，&lt;/p&gt;

&lt;p&gt;它的作用和&lt;strong&gt;weak&lt;/strong&gt;类似，唯一区别是：如果对象A被销毁，所有指向这个对象A的&lt;strong&gt;assign&lt;/strong&gt;属性并不会自动设置为nil。这时候这些属性就变成野指针，再访问这些属性，程序就会crash。&lt;/p&gt;

&lt;p&gt;因此，在ARC下，&lt;strong&gt;assign&lt;/strong&gt;就变成用于修饰基本数据类型(Primitive Type)，也就是非对象/非指针数据类型，如：int、BOOL、float等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意，在非ARC时代，还没有strong的时候。assign是默认值。ARC下，默认值变成strong了。这个要注意一下，否则会引起困扰。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;retain&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;retain&lt;/strong&gt;是以前非ARC时代的特性，在ARC下并不常用。&lt;/p&gt;

&lt;p&gt;它是&lt;strong&gt;strong&lt;/strong&gt;的同义词，两者功能一致。不知道为什么还保留着，这对新手也会造成一定困扰。&lt;/p&gt;

&lt;p&gt;所以，总结一下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;几乎所有情况，都写上&lt;strong&gt;nonatomic&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;对外「只读」的，写上&lt;strong&gt;readonly&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;一般的对象属性，写上&lt;strong&gt;strong&lt;/strong&gt;（用&lt;strong&gt;retain&lt;/strong&gt;也可以，比较少用）&lt;/li&gt;
  &lt;li&gt;需要解决strong reference cycles问题的对象属性，strong改为&lt;strong&gt;weak&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;有mutable(可变)版本的对象属性，strong改为&lt;strong&gt;copy&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;基本数据类型(int, float, BOOL)(非对象属性)，用&lt;strong&gt;assign&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4扩展&quot;&gt;4.扩展&lt;/h3&gt;

&lt;p&gt;其实，除了上面3种经常用到的特性类型，还有2种不太见到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;getter=&lt;/strong&gt; 和 &lt;strong&gt;setter=&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按字面意思，很容易理解，就是重命名getter和setter方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://link.jianshu.com?t=https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;Transitioning to ARC Release Notes&lt;/a&gt;中写道：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You cannot give an accessor a name that begins with new. This in turn means that you can’t, for example, declare a property whose name begins with new unless you specify a different getter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;存取方法不能以&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;开头，如果你要以&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;开头命名一个属性：&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (copy, nonatomic) NSString *newName;&lt;/code&gt;于是会默认生成一个new开头的getter方法：&lt;/p&gt;

&lt;p&gt;这时候就会报错：&lt;code class=&quot;highlighter-rouge&quot;&gt;Property follows Cocoa naming convention for returning 'owned' objects&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;解决办法，就是用&lt;strong&gt;getter=&lt;/strong&gt;重命名getter方法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (copy, nonatomic, getter=theNewName) NSString *newName;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Nullability&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;nullable&lt;/strong&gt;：对象「可为空」&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;nonnull&lt;/strong&gt;：对象「不可为空」&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;null_unspecified&lt;/strong&gt;：「未指定」&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;null_resettable&lt;/strong&gt;：稍有点难理解，就是调用setter去reset属性时，可以传入nil，但是getter返回值，不为空。UIView下面的tintColor，就是null_resettable。这样就保证，即使赋值为nil，也会返回一个非空的值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了更好地和Swift混编(配合Swift的optional类型)，在Xcode 6.3，Objective-C新增了一个语言特性，nullability。具体就是以上4个新特性。&lt;/p&gt;

&lt;p&gt;如果设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;null_resettable&lt;/code&gt;，则要重写setter或getter其中之一，自己做判断，确保真正返回的值不是nil。否则报警告：&lt;code class=&quot;highlighter-rouge&quot;&gt;Synthesized setter 'setName:' for null_resettable property 'name' does not handle nil&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Nullability的写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@property (copy, nullable) NSString *name;
@property (copy, readonly, nonnull) NSArray *allItems;

// 也可以将nullable, nonnull, null_unspecified, null_resettable三个修饰语前面加双下划线，用于修饰指针、参数、返回值等(null_resettable只能在属性括号中使用)
@property (copy, readonly) NSArray * __nonnull allItems;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nullability的默认值：&lt;code class=&quot;highlighter-rouge&quot;&gt;null_unspecified&lt;/code&gt;——未指定。如果某个属性填写了Nullability特性(比如写了nonnull)，没有填写Nullability的属性，会出现如下警告：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pointer is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但是如果每个属性都一一写上，稍嫌麻烦。而因为大多数属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;nonnull&lt;/code&gt;的，所以苹果定义了两个宏，&lt;code class=&quot;highlighter-rouge&quot;&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;(两个宏之间，叫做&lt;strong&gt;Audited Regions&lt;/strong&gt;)。&lt;/p&gt;

&lt;p&gt;将所有属性包在这两个宏中，就无需写&lt;strong&gt;nonnull&lt;/strong&gt;修饰语了，只需要在「可为空」的属性里，写上&lt;strong&gt;nullable&lt;/strong&gt;即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;NS_ASSUME_NONNULL_BEGIN
@interface AAPLList : NSObject &amp;lt;NSCoding, NSCopying&amp;gt;
// 只需要为「不可为空」的参数、属性、返回值加上修饰语nullable即可
- (nullable AAPLListItem *)itemWithName:(NSString *)name;
- (NSInteger)indexOfItem:(AAPLListItem *)item;

@property (copy, nullable) NSString *name;
@property (copy, readonly) NSArray *allItems;
// ...
@end
NS_ASSUME_NONNULL_END

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以！综上所述，attribute最多可以写6个进去：1.原子性、2.存取特性、3.内存管理特性、4.重命名getter、5.重命名setter，6.nullability：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (nonatomic, readonly, copy, getter=theNewTitle, setter=setTheNewTitle:, nullable) NSString *newTitle;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不过，应该没有谁闲得蛋疼会这样写的。&lt;/p&gt;

&lt;p&gt;最短的写法就是什么都不写，连括号都可以不要：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property BOOL isOpen;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;毕。&lt;/p&gt;

&lt;p&gt;作者：AntonyWong&lt;br /&gt;
链接：https://www.jianshu.com/p/035977d1ba89&lt;br /&gt;
来源：简书&lt;br /&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/04/Objective-C%E5%B1%9E%E6%80%A7(property)%E7%9A%84%E7%89%B9%E6%80%A7(attribute)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/04/Objective-C%E5%B1%9E%E6%80%A7(property)%E7%9A%84%E7%89%B9%E6%80%A7(attribute)/</guid>
        
        <category>Object-c</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Jekins build xcode with Parallels virtual machine</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文仅是思路，没有验证或成功案例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kb.parallels.com/123455&quot;&gt;How to change serial number of my virtual machine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackintosher.com/forums/thread/generate-your-own-hackintosh-serial-number-board-serial-number-uuid-mlb-rom-in-clover.306/&quot;&gt;Generate your own Hackintosh Serial Number, Board Serial Number, UUID, MLB, ROM in Clover&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Parallels/jenkins-parallels&quot;&gt;A Jenkins plugin to run builds in Parallels Desktop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jenkinsci/xcode-plugin&quot;&gt;Xcode integration for mobile/iOS developments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 04 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/04/Jekins-build-xcode-with-Parallels-virtual-machine/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/04/Jekins-build-xcode-with-Parallels-virtual-machine/</guid>
        
        <category>Jekins</category>
        
        <category>Xcode</category>
        
        <category>Parallels</category>
        
        
      </item>
    
      <item>
        <title>ITMS-90809: Deprecated API Usage</title>
        <description>&lt;h1 id=&quot;解决itms-90809-deprecated-api-usage-uiwebview-审核不通过&quot;&gt;解决ITMS-90809: Deprecated API Usage UiWebView 审核不通过&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;苹果审核时提示ITMS-90809: Deprecated API Usage - Apple will stop accepting submissions of new apps that use UIWebView APIs starting from April 2020. See https://developer.apple.com/documentation/uikit/uiwebview for more information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决方案：查找代码中哪些代码或者二进制库使用了UiWebView，然后进行修改或者版本升级&lt;/p&gt;

&lt;h2 id=&quot;方法一&quot;&gt;方法一：&lt;/h2&gt;

&lt;p&gt;切换到项目根目录&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; UiWebView &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;方法二&quot;&gt;方法二：&lt;/h2&gt;

&lt;p&gt;切换到项目根目录&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;find &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-type&lt;/span&gt; f | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.a&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.framework&quot;&lt;/span&gt; | xargs &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; UIWebView
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;方法二输出如下&quot;&gt;方法二输出如下：&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;find &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-type&lt;/span&gt; f | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.a&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.framework&quot;&lt;/span&gt; | xargs &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; UIWebView                                                        2 ↵
Binary file ./Pods/Crashlytics/iOS/Crashlytics.framework/Crashlytics matches
Binary file ./Pods/IronSourceVungleAdapter/ISVungleAdapter/ISVungleAdapter.framework/ISVungleAdapter matches
Binary file ./Pods/IronSourceAdColonyAdapter/ISAdColonyAdapter/ISAdColonyAdapter.framework/ISAdColonyAdapter matches
Binary file ./Pods/IronSourceTapjoyAdapter/ISTapjoyAdapter/ISTapjoyAdapter.framework/ISTapjoyAdapter matches
Binary file ./Pods/Fabric/upload-symbols matches
Binary file ./Pods/IronSourceSDK/IronSource/IronSource.framework/Versions/A/IronSource matches
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;理论上上述两种方法都能在代码中找到对应使用了uiwebview的库但是第一种方法以前可以使用最近好像不好使了在此记录下&quot;&gt;理论上上述两种方法都能在代码中找到对应使用了UiWebView的库，但是第一种方法，以前可以使用，最近好像不好使了。在此记录下。&lt;/h2&gt;

</description>
        <pubDate>Fri, 22 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/22/ITMS-90809-Deprecated-API-Usage/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/22/ITMS-90809-Deprecated-API-Usage/</guid>
        
        <category>iOS</category>
        
        <category>Deprecated API Usage</category>
        
        
      </item>
    
      <item>
        <title>驾校迷惑行为图鉴</title>
        <description>&lt;iframe src=&quot;https://video.h5.weibo.cn/1034:4506300806004775/4506310483141226&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; width=&quot;640&quot; height=&quot;420&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Thu, 21 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/21/%E9%A9%BE%E6%A0%A1%E8%BF%B7%E6%83%91%E8%A1%8C%E4%B8%BA%E5%9B%BE%E9%89%B4/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/21/%E9%A9%BE%E6%A0%A1%E8%BF%B7%E6%83%91%E8%A1%8C%E4%B8%BA%E5%9B%BE%E9%89%B4/</guid>
        
        <category>Funny</category>
        
        <category>搞笑</category>
        
        
      </item>
    
      <item>
        <title>Android studio 是从哪里得到库的？</title>
        <description>&lt;h2 id=&quot;android-studio-是从哪里得到库的&quot;&gt;Android studio 是从哪里得到库的？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAulBMVEX///893IQAAAAu2n658M6+vr6CgoJFRUW0tLQr2nwz24DOzs4n2ns63IL9/f1WVlaSkpKGiYdVXFjv7+/5/vul7MEMDAzE8dXs+vGc67zK9Np55abO89zh4eE0NDRxc3LX2NdpbGqZm5oXFxcjIiJa4ZUT2XXj+eyQ57RL3ouv7chm4prv+/Rs4J1+5KhT34/a9+ah6r4tMy8THBdLTkylp6Y5OTm3uLdgYmFvbm/o6ekfIB8qKyuipKP1oSgkAAAEjklEQVR4nO3a6VbqOgAF4JIwtU0qXMooUBAFCueo98h0Ofj+r3WTlEpBgeJiELK/P9KSrBX2SpqhGgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANyAysA9oHS5fLKGXJkndh+/cL3b7Z2uKVelT1k9dmGf80N65y1zLe7HLTswzeQp23JVRBiDeCVdyl9O25ar4nMr3uATQ/r1xG25JnVG+3HK9Zh1wBSigXuLxZklh9z8dfK2XJMK479XV06lnixWhWKy1osM4Bqj1fO37UerUlZTH9xa9Ykzky6ZzPSfk8u+6PPEBZv4M6m1iJMcMtPiiTXcoszvi+iKlGGvsKls0mrfpBuZfWRH2bBM+fDSrfyBnrhlfR1aGF3CxA5rk/u8M7RldC9YvK0r0xixieDY86Vb+pM49yxOahLl6HKhik/jxia7XMyt7M2rb5tEt2CxtmQ3r8YOiy2RMLFHlVv6A1MTKIJ77R4em+hxuk+rFfPQQRpgxUu3/LL878Umgov/RuIG9Q9YgKzjVOO3M9E5gTNrz5il1IzErPPBb2IVlPW75/aGu4Kzkq47MFfX+p4pVVfdZ/mWKrE9OFPFNIhU0fUM81ek89Bg8/Tv9ucdVwXcaB1N59R+5AiEBi+T9+bmRHJLUOeSzb8UN7pR4E/q3suOcarOQZLRYKmWO/ziWt+iz67h3u9YlnB5gFReO6XT8wm3MQdY1N99dslF/zTXb+m4+H39tJ/fu3XgmyUsDbep/VgH43tYl/4V57e/e8Wg30CtfOPY7TNLu6Pf5Ld39FHL5YtGjvJ4ExPspX/Hue3cwscX67+/bslRpoVwt68Pt0uPoqvZVssdJI8Db+8BAADg6P68pb68nyKZ1cXsLXem5lwLh5Cvc8sQYn9c3JH0uRp0JbbmliWd1Wss5LZpa25G9OUfctu0PbcoHXNrpJuZnPHuTQ0j56Xm3mI0Dr6w24tZ1ijJ3Dxv3vJm4t48P1q0VZC2lw5qTzIPOuaWJdIiI3/5hNypqzv5hRd87MjcCMmLz4YxVvfIyFH1jPBGM6Ndbi3xq6f2g/jxeTVH/p3abTU0xa1Zyk4TEuRGSnlPrD1IZpoS9/6RuZVEpxO1U6q2brmNSFP+aYW5FcRFk/wnn2ue/OJ9mZuaPDtBT5zKJYjKbUQm8oatXW4fj/1ZkFtbfs6L/mQHEcrIVG7v4mODkIa6NxExydwKYW3tnm/zMIqHIDe17M+J3FR3kjJBbnKNa6tHmpAmM1VA1J4bQQ3NciuEq35vIzfxKAsWaH9XubXCmO7EGF72t7C2ZrkZCyKXF3K8rucmIlHLEZuscjNUIdVJs0GHfAwGdkG755tcTqQLTqO5mZshZtWx46RINDcxceYKjv1GOsv5dKxqt5r65SbzkR4jucl5wXAe1f1SKZKbmD0CjXD9Ngtra5ebMe6IVVkrLSNrB7m9q7HryLXbrDCRuXXCs4/sH7lWkzOtTR5VWVF70kgHA1gzhcK2L774x91PhbfWBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4v/8BcudDbrAmQyMAAAAASUVORK5CYII=&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。总的来说，只有两个标准的Android library文件服务器：jcenter 和 Maven Central。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jcenter jcenter是一个由 bintray.com维护的Maven仓库 。你可以在&lt;a href=&quot;http://jcenter.bintray.com/&quot;&gt;这里&lt;/a&gt;看到整个仓库的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在项目的build.gradle 文件中如下定义仓库，就能使用jcenter了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;allprojects {
    repositories {
        jcenter()
    }
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Maven Central Maven Central 则是由sonatype.org维护的Maven仓库。你可以在这里看到整个仓库。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：不管是jcenter还是Maven Central ，两者都是Maven仓库&lt;/p&gt;

&lt;p&gt;我们在项目的build.gradle 文件中如下定义仓库，就能使用Maven Central了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;allprojects {
    repositories {
        mavenCentral()
    }
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意，虽然jcenter和Maven Central 都是标准的 android library仓库，但是它们维护在完全不同的服务器上，由不同的人提供内容，两者之间毫无关系。在jcenter上有的可能 Maven Central 上没有，反之亦然。&lt;/p&gt;

&lt;p&gt;除了两个标准的服务器之外，如果我们使用的library的作者是把该library放在自己的服务器上，我们还可以自己定义特有的Maven仓库服务器。Twitter的Fabric.io 就是这种情况，它们在https://maven.fabric.io/public 上维护了一个自己的Maven仓库。如果你想使用Fabric.io的library，你必须自己如下定义仓库的url。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;repositories {
    maven { url 'https://maven.fabric.io/public' }
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在里面使用相同的方法获取一个library。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;dependencies {
    compile 'com.crashlytics.sdk.android:crashlytics:2.2.4@aar'
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是将library上传到标准的服务器与自建服务器，哪种方法更好呢？当然是前者。如果将我们的library公开，其他开发者除了一行定义依赖名的代码之外不需要定义任何东西。因此这篇文章中，我们将只关注对开发者更友好的jcenter 和 Maven Central 。&lt;/p&gt;

&lt;p&gt;实际上可以在Android Studio上使用的除了Maven 仓库之外还有另外一种仓库：Ivy 仓库&lt;/p&gt;

&lt;h2 id=&quot;理解jcenter和maven-central&quot;&gt;理解jcenter和Maven Central&lt;/h2&gt;

&lt;p&gt;为何有两个标准的仓库？&lt;/p&gt;

&lt;p&gt;事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。&lt;/p&gt;

&lt;p&gt;起初，Android Studio 选择Maven Central作为默认仓库。如果你使用老版本的Android Studio创建一个新项目，mavenCentral()会自动的定义在build.gradle中。&lt;/p&gt;

&lt;p&gt;但是Maven Central的最大问题是对开发者不够友好。上传library异常困难。上传上去的开发者都是某种程度的极客。同时还因为诸如安全方面的其他原因，Android Studio团队决定把默认的仓库替换成jcenter。正如你看到的，一旦使用最新版本的Android Studio创建一个项目，jcenter()自动被定义，而不是mavenCentral()。&lt;/p&gt;

&lt;p&gt;有许多将Maven Central替换成jcenter的理由，下面是几个主要的原因。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jcenter通过CDN发送library，开发者可以享受到更快的下载体验。&lt;/li&gt;
  &lt;li&gt;jcenter是全世界最大的Java仓库，因此在Maven Central 上有的，在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。&lt;/li&gt;
  &lt;li&gt;上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情&lt;/li&gt;
  &lt;li&gt;友好的用户界面&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gradle是如何从仓库上获取一个library的&quot;&gt;gradle是如何从仓库上获取一个library的？&lt;/h2&gt;

&lt;p&gt;我们在 build.gradle输入如下代码的时候，这些库是如果奇迹般下载到我们的项目中的。 &lt;code class=&quot;highlighter-rouge&quot;&gt;compile 'com.inthecheesefactory.thecheeselibrary:fb-like:0.9.3' &lt;/code&gt;一般来说，我们需要知道library的字符串形式，包含3部分: &lt;code class=&quot;highlighter-rouge&quot;&gt;GROUP_ID:ARTIFACT_ID:VERSION&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的例子中，GROUP_ID是com.inthecheesefactory.thecheeselibrary ，ARTIFACT_ID是fb-like，VERSION是0.9.3。&lt;/p&gt;

&lt;p&gt;GROUP_ID定义了library的group。有可能在同样的上下文中存在多个不同功能的library。如果library具有相同的group，那么它们将共享一个GROUP_ID。通常我们以开发者包名紧跟着library的group名称来命名，比如com.squareup.picasso。然后ARTIFACT_ID中是library的真实名称。至于VERSION，就是版本号而已，虽然可以是任意文字，但是我建议设置为x.y.z的形式，如果喜欢还可以加上beta这样的后缀。&lt;/p&gt;

&lt;p&gt;下面是Square library的一个例子。你可以看到每个都可以很容易的分辨出library和开发者的名称。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;dependencies {
  compile 'com.squareup:otto:1.3.7'
  compile 'com.squareup.picasso:picasso:2.5.2'
  compile 'com.squareup.okhttp:okhttp:2.4.0'
  compile 'com.squareup.retrofit:retrofit:1.9.0'
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么在添加了上面的依赖之后会发生什么呢？简单。Gradle会询问Maven仓库服务器这个library是否存在，如果是，gradle会获得请求library的路径，一般这个路径都是这样的形式：GROUP_ID/ARTIFACT_ID/VERSION_ID。比如可以在http://jcenter.bintray.com/com/squareup/otto/1.3.7 和 https://oss.sonatype.org/content/repositories/releases/com/squareup/otto/1.3.7/&lt;/p&gt;

&lt;p&gt;下获得com.squareup:otto:1.3.7的library文件。&lt;/p&gt;

&lt;p&gt;然后Android Studio 将下载这些文件到我们的电脑上，与我们的项目一起编译。整个过程就是这么简单，一点都不复杂。&lt;/p&gt;

&lt;p&gt;我相信你应该清楚的知道从仓库上下载的library只是存储在仓库服务器上的jar 或者aar文件而已。有点类似于自己去下载这些文件，拷贝然后和项目一起编译。但是使用gradle依赖管理的最大好处是你除了添加几行文字之外啥也不做。library一下子就可以在项目中使用了。&lt;/p&gt;

&lt;h2 id=&quot;了解aar文件&quot;&gt;了解aar文件&lt;/h2&gt;

&lt;p&gt;我刚才说了仓库中存储的有两种类型的library：jar 和 aar。jar文件大家都知道，但是什么是aar文件呢？&lt;/p&gt;

&lt;p&gt;aar文件时在jar文件之上开发的。之所以有它是因为有些Android Library需要植入一些安卓特有的文件，比如AndroidManifest.xml，资源文件，Assets或者JNI。这些都不是jar文件的标准。&lt;/p&gt;

&lt;p&gt;因此aar文件就时发明出来包含所有这些东西的。总的来说它和jar一样只是普通的zip文件，不过具有不同的文件结构。jar文件以classes.jar的名字被嵌入到aar文件中。其余的文件罗列如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/AndroidManifest.xml (mandatory)
/classes.jar (mandatory)
/res/ (mandatory)
/R.txt (mandatory)
/assets/ (optional)
/libs/*.jar (optional) /jni//*.so (optional) /proguard.txt (optional) /lint.jar (optional)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到.aar文件是专门为安卓设计的。因此这篇文章将教你如何创建与上传一个aar形式的library。&lt;/p&gt;

&lt;h2 id=&quot;buildgradle与gradle-warpper-的区别和联系&quot;&gt;build.gradle与gradle-warpper 的区别和联系&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160518093304476&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图中圈出位置所示，这俩个文件在项目中的位置。&lt;/p&gt;

&lt;p&gt;build.gradle 文件制定编译时的一些条件和依赖关系。 gradle-warpper.properties主要用来制定当前使用的gradle版本从哪里获取。以及一些其他的参数。&lt;/p&gt;

&lt;p&gt;下面来分析一下这俩文件中的内容：&lt;/p&gt;

&lt;p&gt;build.gradle 这个文件的内容并不是固定的，根据项目的需要会有不同的设置。这里给出一般情况下的内容： 这是Module的gradle文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//这里指明这是一个android工程，也可以填com.android.library
//指明这是一个类库
apply plugin: 'com.android.application'
android {
//使用的编译版本SDK21
    compileSdkVersion 21
    //buildtool版本 指定为21.1.1
    buildToolsVersion 21.1.1
    defaultConfig {
    //最小SDK17
        minSdkVersion 17
        //目标版本19
        targetSdkVersion 19
    }
    // 打包签名
    signingConfigs {
    //指定debug模式下使用的签名文件
        debug { storeFile file(&quot;debug.keystore&quot;) }

        release {
        //发布正式版本模式下的使用的签名文件
            storeFile file('release.keystore')
            storePassword 'thisiskeystorepassword'
            keyAlias 'nim_demo'
            keyPassword 'thisiskeypassword'
        }
    }
//编译时脚本运行环境
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
            manifestPlaceholders = [AMAP_KEY: &quot;09fd4efd3e28e9bf1f449ecec7d34bfe&quot;]
        }
//正式版本要混淆
        release {
            minifyEnabled true
            zipAlignEnabled true
            proguardFile('proguard.cfg')
            signingConfig signingConfigs.release
            manifestPlaceholders = [AMAP_KEY: &quot;ee20324fba1c7f4ad7a4a207e7f08e8d&quot;]
        }
    }
    sourceSets {

        main {
        //指定文件映射关系
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res', 'res-avchat', 'res-chatroom']
            assets.srcDirs = ['assets']
            jniLibs.srcDirs = ['libs', 'libs-sdk']

        }

    }
    //防止lint时报错
lintOptions {
        abortOnError false
    }
    packagingOptions {
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
    }

}
//添加依赖jar,库工程
dependencies {
//依赖文件夹下的所有文件
    compile fileTree(dir: 'libs', exclude: ['android-support-*.jar'], include: '*.jar')

    compile project(path: ':uikit')
    compile 'com.android.support:appcompat-v7:21.0.3'
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个根目录下的gradle文件，这个文件的设置对project下的所有module都是有效的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;buildscript {
//指定要使用的gradle版本
    dependencies {
        classpath 'com.android.tools.build:gradle:2.0.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
   // apply from: 'script.gradle', to: buildscript
}
//指定远程仓库，建议使用jcenter
allprojects {
    repositories {
        jcenter()
    }
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个gradle-wrapper。properties文件。只要设置gradle的缓存地址和下载地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#Wed May 18 07:57:25 CST 2016
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
#指定gradle的下载地址
distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 19 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/19/Android-studio-%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BE%97%E5%88%B0%E5%BA%93%E7%9A%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/19/Android-studio-%E6%98%AF%E4%BB%8E%E5%93%AA%E9%87%8C%E5%BE%97%E5%88%B0%E5%BA%93%E7%9A%84/</guid>
        
        <category>Android</category>
        
        <category>Gradle</category>
        
        
      </item>
    
      <item>
        <title>提升团队开发效率 - Nexus Repository</title>
        <description>&lt;h1 id=&quot;提升团队开发效率---nexus-repository&quot;&gt;提升团队开发效率 - Nexus Repository&lt;/h1&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.51cto.com/14579491/2451530&quot;&gt;https://blog.51cto.com/14579491/2451530&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于提升团队开发效率有很多可以讲，这里讨论一个比较简单易行并且”效果明显”的方法。
在有些公司，如果对访问外网做了限制的话，可能需要走统一的代理才能访问外网。并且管理更&amp;gt; &amp;gt; 加严格的可能还会对访问的外部资源签发自签名的证书，这样会导致几个问题&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;每个人需要在工作电脑上配置代理&lt;/li&gt;
    &lt;li&gt;不同的软件/平台配置代理的方式并不统一&lt;/li&gt;
    &lt;li&gt;访问速度较慢&lt;/li&gt;
    &lt;li&gt;可能需要把自签名的证书import到对应的trust store中，并且可能要定期或不定期更新&lt;/li&gt;
    &lt;li&gt;以上这些问题可能会影响到多种角色的人，无论是开发，测试，甚至运维。(只要和打包扯上关系的，或多或少都有影响)。假如1个人要花30分钟处理以上问题，那么10个人就要5个小时，总体算下来时间还是很可观的，非常影响整体的效率。(如果是个人开发者，可能意义就不大了)有什么解决的方法没有?或许Nexus Repository是一个选择。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是nexus有什么用&quot;&gt;什么是Nexus，有什么用?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;在开发当中经常要使用各种依赖库，比如Java/Android中的maven central，Python中的pypi等等。&lt;/li&gt;
  &lt;li&gt;Nexus Repository是一个仓库管理器，通过它，我们可以代理各种public的仓库，也可以构建自己的私有仓库。使得软件开发中的依赖管理、编译、发布、部署等更加方便和高效。&lt;/li&gt;
  &lt;li&gt;Nexus Repository有Pro的付费版本，但是一般我们使用它的免费OSS版本即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何使用nexus&quot;&gt;如何使用Nexus?&lt;/h2&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;这里我使用docker来安装，当然你也可以直接下载安装包安装。&lt;/p&gt;

&lt;h4 id=&quot;下载nexus的最新image&quot;&gt;下载nexus的最新image&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker pull sonatype/nexus3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;绑定端口运行&quot;&gt;绑定端口，运行&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 8081:8081 &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; nexus sonatype/nexus3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;本机测试&quot;&gt;本机测试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;打开浏览器输入http://localhost:8081/
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看到这个界面，就说明安装成功了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519154442.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首次安装成功，会提示我们修改默认的admin密码，我们需要shell进去，拿到密码&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; nexus bash
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;根据提示，进入对应目录，查看密码
如果要stop或者start nexus的话，执行以下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker stop/start nexus
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;前边我们并没有设置自启动，如果需要container随着docker启动而自启动的话，可以执行以下命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker update &lt;span class=&quot;nt&quot;&gt;--restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;always nexus
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;

&lt;h4 id=&quot;androidjava&quot;&gt;Android、Java&lt;/h4&gt;
&lt;p&gt;默认的repo：
&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519154847.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android和Java会共用大部分的public maven，常见的有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;google&lt;/li&gt;
  &lt;li&gt;maven central&lt;/li&gt;
  &lt;li&gt;jcenter&lt;/li&gt;
  &lt;li&gt;fabric&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，Android还会用到&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gradle plugin&lt;/li&gt;
  &lt;li&gt;gradle distribution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以gradle distribution为例，看看如何添加这个配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519155152.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里注意，它的type是raw(proxy)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;常用的maven，以及对应的type&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519155355.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;依次创建完对应的repo之后，调整一下maven-public，把所有的maven2类型的repo都加进去&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519155440.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android客户端配置&lt;/p&gt;

&lt;p&gt;​	以Android项目为例，看看我们需要修改哪些配置&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先用任意文本编辑器打开项目(不要用Android Studio或IDEA，它会自动触发gradle sync)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改项目build.gradle的repo，把现有的repo全部删掉或者注释掉，然后换成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;maven { url 'http://localhost:8081/repository/maven-public/' }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;修改项目settings.gradle，配置gradle plugin的repo，在文件顶部加入&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-groovy highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;pluginManagement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maven&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'http://localhost:8081/repository/maven-public/'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519160123.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;修改文件gradle/wrapper/gradle-wrapper.properties&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519160238.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/newstrong/newstrong.github.io/master/img/20200519160123.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;nodejs&quot;&gt;NodeJs&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	创建一个npm (proxy)的repo，remote url是
	https://registry.npmjs.org/
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	查看当前npm的registry - $ npm get registry
	设置npm mirror
	替换称你自己的地址
	$ npm set http://localhost:8081/repository/npm-registry/
	还原npm registry
	$ npm set registry https://registry.npmjs.org/
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;python&quot;&gt;Python&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	创建一个pypi (proxy)的repo，remote url是
	https://pypi.org
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	查看当前的配置信息，$ pip3 config list -v
	在用户目录下创建文件~/.pip/pip.conf(如果不存在的话)，加入以下配置
	
	[global]
	index-url = http://localhost:8081/repository/pypi-proxy/simple
	trusted-host = localhost
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里要特别注意，index-url最后的simple是必须要有的。simple之前的地址就是nexus的访问地址，请替换成自己的地址。
因为我们没有使用https，所以需要在trusted-host里边加入我们的host&lt;/p&gt;

&lt;h4 id=&quot;ios&quot;&gt;iOS&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	创建一个cocoapods (proxy)的repo，remote url是
	https://cdn.cocoapods.org/
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	cocoapods比较麻烦的地方在于客户端只支持https，我暂时没有做测试。解决方案是使用自签名证书来开启https。
	有兴趣的同学可以根据官方文档的说明去调调看 - CocoaPods Repositories
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;​		总结一下，我们了解了Nexus Repository作为一种包依赖管理器，可以解决在公司内部的依赖下载配置繁琐以及慢的问题然后讲解了如何安装配置Nexus
随后，针对不同的平台分别做了配置讲解，如Android/Java, NodeJs, Python, 和iOS
​		这里只是列举了一部分，实际上Nexus支持的还有很多，比如&lt;strong&gt;apt&lt;/strong&gt;, &lt;strong&gt;conda&lt;/strong&gt;, &lt;strong&gt;docker&lt;/strong&gt;, &lt;strong&gt;go&lt;/strong&gt;, &lt;strong&gt;nuget&lt;/strong&gt;, &lt;strong&gt;rubygems&lt;/strong&gt;, &lt;strong&gt;yum&lt;/strong&gt; 等等。如果有相应的需要，可以找对应的资料进行配置使用。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/14/%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87-Nexus-Repository/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/14/%E6%8F%90%E5%8D%87%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87-Nexus-Repository/</guid>
        
        <category>Nexus</category>
        
        <category>Maven</category>
        
        
      </item>
    
      <item>
        <title>使用Kotlin创建自定义View</title>
        <description>&lt;h1 id=&quot;使用kotlin创建自定义view&quot;&gt;使用Kotlin创建自定义View&lt;/h1&gt;

&lt;p&gt;通过Android Studio点击 New-Kotlin Class/Files 创建的一个类，指定它实现一个View，例如：FrameLayout。此时IDE会提示你需要实现它的构造方法，Alert+Enter 即可，完成后如下：&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FrameLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时只实现了View的一个构造方法，在代码中初始化并使用并没有问题，但是不能再XML中引用，因为自定义View需要实现类似以下的构造方法：&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FrameLayout&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AttributeSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AttributeSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@RequiresApi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;VERSION_CODES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LOLLIPOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@NonNull&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AttributeSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defStyleRes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defStyleRes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还好Kotlin有constructor关键字，用来在类名后指定主构造方法，或者单独在类中，指定次级构造方法。&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FrameLayout&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AttributeSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AttributeSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的写法其实不是很好看，不太符合Kotlin极简思想，请参考更简单的实现：&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomViewTest&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@JvmOverloads&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AttributeSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FrameLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defStyleAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是不是够极简，但是在Java调用这个类的构造方法时候，因为Java没有默认参数的这种写法，需要全部指定所有的参数。&lt;/p&gt;

&lt;h2 id=&quot;结论全局kotlin使用最后一种极简的写法java-kotlin混编特别是需要java初始化kotlin自定义view则使用constructor写法&quot;&gt;结论：全局Kotlin，使用最后一种极简的写法，Java-Kotlin混编，特别是需要Java初始化Kotlin自定义View，则使用Constructor写法。&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;原文：&lt;/p&gt;

&lt;p&gt;​	&lt;a href=&quot;https://antonioleiva.com/custom-views-android-kotlin/&quot;&gt;https://antonioleiva.com/custom-views-android-kotlin/&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 14 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/14/%E4%BD%BF%E7%94%A8Kotlin%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89View/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/14/%E4%BD%BF%E7%94%A8Kotlin%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89View/</guid>
        
        <category>Android</category>
        
        <category>Kotlin</category>
        
        <category>自定义View</category>
        
        
      </item>
    
      <item>
        <title>iOS DeepLink 调研与实践</title>
        <description>&lt;h1 id=&quot;ios-deeplink-调研与实践&quot;&gt;iOS DeepLink 调研与实践&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文链接：&lt;a href=&quot;https://juejin.im/post/5d5cf482f265da03e05b170f&quot;&gt;iOS DeepLink调研与实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是deeplink&quot;&gt;什么是DeepLink&lt;/h2&gt;

&lt;p&gt;使用统一资源标识符（URI）链接到一个App中特定的位置，而不是简单地打开App。 用户未安装App的情况下，一样可以在用户安装App后重新还原用户之前预览的页面。常见的有以下2种实现方式。&lt;/p&gt;

&lt;h3 id=&quot;url-scheme-ios8以上可用&quot;&gt;URL Scheme (iOS8以上可用)&lt;/h3&gt;

&lt;p&gt;我们通常只能使用scheme。这种方式需要通过safari中唤醒APP，但是这种方式需要提前判断系统中是否安装了能够响应此scheme的app，并且这种方式在微信等中是被禁用了的。如果没有安装app则该链接变成了无效链接。&lt;/p&gt;

&lt;h3 id=&quot;1-如何支持-url-scheme&quot;&gt;1. 如何支持 URL Scheme&lt;/h3&gt;

&lt;p&gt;设置info.plist&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/21/16cb21a4db991839?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假如我&lt;code class=&quot;highlighter-rouge&quot;&gt;URL Schemes&lt;/code&gt;填写的是&lt;code class=&quot;highlighter-rouge&quot;&gt;rrddl&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Identifier&lt;/code&gt;填写的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;renrendai.com&lt;/code&gt;。那么我就可以在safari地址栏中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;rrddl://renrendai.com&lt;/code&gt;来打开我们的app。&lt;/p&gt;

&lt;h4 id=&quot;2-原理&quot;&gt;2. 原理&lt;/h4&gt;

&lt;p&gt;iPhone在安装应用时可以检测到&lt;code class=&quot;highlighter-rouge&quot;&gt;info.plist&lt;/code&gt;文件中是否有&lt;code class=&quot;highlighter-rouge&quot;&gt;CFBundleURLTypes&lt;/code&gt;，如果存在则将相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;schemes&lt;/code&gt;注册到系统中，如有其它app通过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;UIApplication.shared.openURL(URL(string: &quot;rrddl://renrendai.com&quot;)!)
复制代码
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者safari打开时，系统会查找已注册的Schemes来启动对应的app。&lt;/p&gt;

&lt;h3 id=&quot;3-如何限制url打开app&quot;&gt;3. 如何限制url打开app&lt;/h3&gt;

&lt;p&gt;如果不想被其它应用无端调起可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;open url&lt;/code&gt;方法中通过host和path等条件加以限制。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -&amp;gt; Bool {
    let components = URLComponents(string: url.absoluteString)
    let pathPool = [&quot;dl&quot;, &quot;h5&quot;, &quot;tab&quot;]
    if pathPool.contains(components?.path ?? &quot;&quot;) {
        JumpManager.handel(url) //处理url跳转
        return true
    }
    return false
}
复制代码
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;

&lt;p&gt;1.不能检测用户是否安装了app，对没有安装app的用户没有引导作用。&lt;/p&gt;

&lt;p&gt;2.没有唯一的应用标识，无法保证用户不会安装注册相同URL方案的第三方app。&lt;/p&gt;

&lt;h2 id=&quot;universal-links&quot;&gt;Universal Links&lt;/h2&gt;

&lt;p&gt;Universal Links就是一个通用链接，iOS9以上的用户，可以通过点击这个链接无缝的重定向到一个app应用，而不需要通过safari打开跳转。如果用户没有安装这个app，则会在safari中打开这个链接指向的网页。(现已被微信封禁)&lt;/p&gt;

&lt;h3 id=&quot;一universal-link的基本运作流程&quot;&gt;一、Universal Link的基本运作流程&lt;/h3&gt;

&lt;p&gt;1 app第一次安装或者版本更新后第一次启动，app向工程里配置的域名发起Get请求拉取&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-association&lt;/code&gt;这个Json文件。&lt;/p&gt;

&lt;p&gt;2 app将&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-association&lt;/code&gt;注册给系统。&lt;/p&gt;

&lt;p&gt;3 由iPhone上的任意&lt;code class=&quot;highlighter-rouge&quot;&gt;webView&lt;/code&gt;发起跳转的url(在webKit做了处理)，如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-association&lt;/code&gt;注册的通用链接则打开App，触发&lt;code class=&quot;highlighter-rouge&quot;&gt;Universal Link delegate&lt;/code&gt;；没命中，&lt;code class=&quot;highlighter-rouge&quot;&gt;webView&lt;/code&gt;继续跳转url。&lt;/p&gt;

&lt;h3 id=&quot;二如何让app支持universal-links&quot;&gt;二、如何让app支持Universal Links&lt;/h3&gt;

&lt;h4 id=&quot;1创建一个名字叫做apple-app-site-association包含固定格式的json文件&quot;&gt;1.创建一个名字叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-site-association&lt;/code&gt;，包含固定格式的json文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
&quot;applinks&quot;: {
        &quot;apps&quot;: [],
        &quot;details&quot;: [
            {
                &quot;appID&quot;: &quot;teamID.bundleId&quot;,
                &quot;paths&quot;: [&quot;/deaplink&quot;,&quot;/wwdc/news/&quot;,&quot;*&quot;]
            }
        ]
    }
}
复制代码
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;注意&quot;&gt;注意:&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;appID&lt;/code&gt; 的格式为&lt;code class=&quot;highlighter-rouge&quot;&gt;teamID.bundleId&lt;/code&gt;形式。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-site-association&lt;/code&gt;不能带后缀名&lt;/p&gt;

&lt;h4 id=&quot;2-apple-app-site-association放置位置&quot;&gt;2. apple-app-site-association放置位置&lt;/h4&gt;

&lt;p&gt;1.文件配置完成之后，将其上传到你的服务器根目录或者&lt;code class=&quot;highlighter-rouge&quot;&gt;.well-known&lt;/code&gt;这个子目录下(iOS 9.3才可以)&lt;/p&gt;

&lt;p&gt;2.确保使用&lt;code class=&quot;highlighter-rouge&quot;&gt;https://yourdomain.com/apple-app-site-association&lt;/code&gt; 这个链接可以访问到，&lt;code class=&quot;highlighter-rouge&quot;&gt;yourdomain.com&lt;/code&gt;为你的服务器域名。&lt;/p&gt;

&lt;h4 id=&quot;3-在哪里获取teamid&quot;&gt;3. 在哪里获取TeamID?&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/21/16cb295a4dc6283d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-paths规则&quot;&gt;4. paths规则&lt;/h4&gt;

&lt;p&gt;1.使用&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;配置，则整个网站都可以使用。&lt;/p&gt;

&lt;p&gt;2.使用特定的URL，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;/user/home&lt;/code&gt;来指定某一个特殊的链接。&lt;/p&gt;

&lt;p&gt;3.在特定URL后面添加&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;/user/*&lt;/code&gt;, 来指定网站的某一部分。&lt;/p&gt;

&lt;p&gt;4.除了使用&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;来匹配任意字符，你也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;来匹配单个字符，你可以在路径当中结合这两个字符使用，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/user/*/201?&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;5-app-ids-配置&quot;&gt;5. app IDs 配置&lt;/h4&gt;

&lt;p&gt;进去登录苹果开发者中心，在&lt;code class=&quot;highlighter-rouge&quot;&gt;identifiers&lt;/code&gt;下&lt;code class=&quot;highlighter-rouge&quot;&gt;App IDs&lt;/code&gt; 打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Associated Domains&lt;/code&gt;开关。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/21/16cb28d096a5b9ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-项目配置&quot;&gt;6. 项目配置&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/21/16cb290797352f84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;domains&lt;/code&gt;可以添加多个，前缀必须为&lt;code class=&quot;highlighter-rouge&quot;&gt;applinks:&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;applinks:&lt;/code&gt;后为你的服务器的域名。值得注意的是要想触发Universal Link拦截必须跨域，假如Universal Link配置的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;wx.renrendai.com&lt;/code&gt; 这个域名，并且对这个域名下比如&lt;code class=&quot;highlighter-rouge&quot;&gt;/point /home /user&lt;/code&gt; 等&lt;code class=&quot;highlighter-rouge&quot;&gt;urlPath&lt;/code&gt;进行了识别，也就是说只有当你访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://wx.renrendai.com/point/xxx&lt;/code&gt; 才会触发Universal Link拦截，而正经的Url &lt;code class=&quot;highlighter-rouge&quot;&gt;https//www.renrendai.com/point/xxx&lt;/code&gt; 是不会触发Universal Link的拦截。&lt;/p&gt;

&lt;h4 id=&quot;7-项目中需要做的处理&quot;&gt;7. 项目中需要做的处理&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&amp;gt; Void) -&amp;gt; Bool {
    if userActivity.activityType == &quot;NSUserActivityTypeBrowsingWeb&quot; {
        let url = userActivity.webpageURL
        JumpManager.handel(url) //处理url跳转
        return true
    }
    return false
}
复制代码
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三验证universal-links配置是否成功&quot;&gt;三、验证Universal Links配置是否成功&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;快捷验证，在备忘录中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;https://yourdomain.com/apple-app-site-association&lt;/code&gt; 长按这个链接，出现在XXXapp打开即为成功。(在信息里同理)&lt;/li&gt;
  &lt;li&gt;使用 &lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool/&quot;&gt;苹果官方验证&lt;/a&gt;验证文件是否能被苹果请求到。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;短链服务器端的相关实现&quot;&gt;&lt;a href=&quot;https://juejin.im/post/5d2d33885188253a2e1b8626&quot;&gt;短链服务器端的相关实现&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html&quot;&gt;苹果官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/articles/20463&quot;&gt;好的文章&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;遇到问题&quot;&gt;遇到问题:&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;官网说&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-site-association&lt;/code&gt;放置在服务器根目录或者&lt;code class=&quot;highlighter-rouge&quot;&gt;.well-known&lt;/code&gt;这个子目录下即可,在真机模拟是发现在&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS9.3-iOS12&lt;/code&gt; 请求的地址是在&lt;code class=&quot;highlighter-rouge&quot;&gt;.well-known&lt;/code&gt;下而非根目录下&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/21/16cb2a499c972a29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;广告时间&quot;&gt;广告时间&lt;/h2&gt;

&lt;p&gt;最后惯例，欢迎大家star我们的&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Frrd-fe%2Fblog&quot;&gt;人人贷大前端团队博客&lt;/a&gt;，所有的文章还会同步更新到&lt;a href=&quot;https://www.zhihu.com/people/ren-ren-dai-da-qian-duan-ji-zhu-zhong-xin/activities&quot;&gt;知乎专栏&lt;/a&gt; 和 &lt;a href=&quot;https://juejin.im/user/5cb690b851882532941dd5d9&quot;&gt;掘金账号&lt;/a&gt;，我们每周都会分享几篇高质量的大前端技术文章。如果你喜欢这篇文章，希望能动动小手给个赞。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/14/iOS-DeepLink-%E8%B0%83%E7%A0%94%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/14/iOS-DeepLink-%E8%B0%83%E7%A0%94%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
        
        <category>iOS</category>
        
        <category>DeepLink</category>
        
        
      </item>
    
  </channel>
</rss>
